<!doctype html>
<html lang="en-us">
  <head>
    <title>V8 Notes // Xploiter</title>
    <link rel="shortcut icon" href="/favicon.ico" />
    <meta charset="utf-8" />
    <meta name="generator" content="Hugo 0.87.0" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" content="John Sherchan" />
    <meta name="description" content="" />
    <link rel="stylesheet" href="https://xpldotjs.github.io/css/main.min.88e7083eff65effb7485b6e6f38d10afbec25093a6fac42d734ce9024d3defbd.css" />

    
    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="V8 Notes"/>
<meta name="twitter:description" content="Overview This is just a note to better understand the V8 Turbofan. This note heavily relies on other blogpost which are mentioned in the References section.
IR An intermediate representation is a representation of a program “between” the source and target languages. A good IR is one that is fairly independent of the source and target languages, so that it maximizes its ability to be used in a retargetable compiler. Ignition collects the profiling information or feedback about the inputs to certain operations during execution."/>

    <meta property="og:title" content="V8 Notes" />
<meta property="og:description" content="Overview This is just a note to better understand the V8 Turbofan. This note heavily relies on other blogpost which are mentioned in the References section.
IR An intermediate representation is a representation of a program “between” the source and target languages. A good IR is one that is fairly independent of the source and target languages, so that it maximizes its ability to be used in a retargetable compiler. Ignition collects the profiling information or feedback about the inputs to certain operations during execution." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://xpldotjs.github.io/posts/v8-notes/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-08-21T00:25:23+05:45" />
<meta property="article:modified_time" content="2021-08-21T00:25:23+05:45" />



  </head>
  <body>
    <header class="app-header">
      <a href="https://xpldotjs.github.io"><img class="app-header-avatar" src="/avatar.jpg" alt="John Sherchan" /></a>
      <h1>Xploiter</h1>
      <nav class="app-header-menu">
          <a class="app-header-menu-item" href="/tags/">Tags</a>
      </nav>
      <p>In love with Browser Exploitation</p>
      <div class="app-header-social">
        
          <a href="https://github.com/xpldotjs" target="_blank" rel="noreferrer noopener">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-github">
  <title>My Github</title>
  <path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path>
</svg>
          </a>
        
      </div>
    </header>
    <main class="app-container">
      
  <article class="post">
    <header class="post-header">
      <h1 class ="post-title">V8 Notes</h1>
      <div class="post-meta">
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar">
  <title>calendar</title>
  <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line>
</svg>
          Aug 21, 2021
        </div>
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock">
  <title>clock</title>
  <circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline>
</svg>
          17 min read
        </div>
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tag">
  <title>tag</title>
  <path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path><line x1="7" y1="7" x2="7.01" y2="7"></line>
</svg>
              <a class="tag" href="https://xpldotjs.github.io/tags/browser/">browser</a>
              <a class="tag" href="https://xpldotjs.github.io/tags/v8/">v8</a>
              <a class="tag" href="https://xpldotjs.github.io/tags/chrome/">chrome</a>
              <a class="tag" href="https://xpldotjs.github.io/tags/v8notes/">v8notes</a>
        </div>
      </div>
    </header>
    <div class="post-content">
      <h3 id="overview">Overview</h3>
<p>This is just a note to better understand the V8 Turbofan. This note heavily relies on other blogpost which are mentioned in the References section.</p>
<h3 id="ir">IR</h3>
<p>An intermediate representation is a representation of a program “between” the source and target languages.
A good IR is one that is fairly independent of the source and target languages, so that it maximizes its ability
to be used in a retargetable compiler.
Ignition collects the profiling information or feedback about the inputs to certain operations during execution.
Some of this feedback is used by ignition itself to speed up subsequent interpretation of the bytecode.</p>
<p>literal objects =&gt; strings, numbers, object-literal boilerplate, etc</p>
<h3 id="how-v8-works">How V8 works</h3>
<p>V8 takes javascript code and passes it to the <code>parser</code>, then the parser creates an <code>Abstract Syntax Tree (AST)</code> representation
for the source code. Then the AST is feeded into <code>BytecodeGenerator</code> which is part of the Ignition Interpreter, where it is turned into a stream of bytecodes. This stream of bytecodes is then executed by Ignition.</p>
<h3 id="v8-notes--notes-for-issue-1016450">V8 Notes / Notes For Issue 1016450</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-plain" data-lang="plain">----- Flags -----
--allow-natives-syntax  =&gt; enable runtime functions
--trace-turbo   =&gt; generates .cfg and .json to get better graph view of different optimization passes using turbolizer
--trace-opt     =&gt; trace optimizations
--trace-deopt   =&gt; trace deoptimizations
--trace-turbo-reduction =&gt; traces of reduction
--print-ast     =&gt; print Abstract Syntax Tree, internally generated by the V8
--print-bytecode    =&gt; print bytecode
--print-opt-code    =&gt; prints optimized codes
--turbo-filter  =&gt; optimization filter for turbofan
--turbo-inlining    =&gt; enable inlining 
--trace-turbo-inlining  =&gt; trace turbofan inlining   
--turbo-verify  =&gt; very turbofan graphs at each phase
--turbo-types   =&gt; use typed lowering in turbofan
--turbo-asm     =&gt; enable asm.js
--trubo-stats   =&gt; print turbofan statistics
----- Functions -----
%DebugPrint(x)  =&gt; Print all internal information about the object or primitive value
%SystemBreak()  =&gt; trigger debugging interrupt / set breakpoint in JS
%DisassembleFunction()  =&gt; Disassemble the function
%OptimizeFunctionOnNextCall() =&gt; trigger optimization of the function in V8
----- General Terms -----
literal objects =&gt; strings, numbers, object-literal boilerplate, etc 
SignedSmall     =&gt; Small integer (Signed 32-bit or 31bit) and represented as SMI
Number          =&gt; regular number (SignedSmall etc.)
NumberOrOddball =&gt; includes all values from Number plus undefined, null, true and false
</code></pre></div><p>To see other runtime function look at <code>src/runtime</code></p>
<h4 id="turbolizer">Turbolizer</h4>
<p>Tool used to debug Turbofan&rsquo;s <code>sea of nodes</code> graph</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-plain" data-lang="plain">cd tools/turbolizer
npm i
npm run-script build
python -m SimpleHTTPServer
</code></pre></div><h4 id="speculative-optimization">Speculative Optimization</h4>
<p>Sample code:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">add</span>(<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span>) {
  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">x</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">y</span>;
}
<span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">add</span>(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>));
</code></pre></div><ol>
<li>optimizing compiler can only eliminate an expression if it knows for sure that this expression won’t cause any observable side effects and doesn’t raise exceptions</li>
<li>In case of optimization, let&rsquo;s see for only numbers, it put checks in place to check that values such as x and y are numbers, if either of these checks
fails it go back to interpreting the bytecode instead (Deoptimization).</li>
<li>The feedback collected by Ignition is stored in Feedback Vector. Feedback Vector data structure is linked from the closure and contains slots to store
different kinds of feedback, i.e., bisets, closure, or hidden classes, depending on the concrete inline cache. The closure also links to the SharedFunctionInfo, which contains the general information about the functions such as source position, bytecode, strict/sloppy mode etc. There is a link to the context as well, which contains the values for the free variables of the functiohn and provides access to the global object (i.e., the <code>&lt;iframe&gt;</code> specific data structure)</li>
<li>In case of the add function, Feedback Vector has one interesting slot i.e., BinaryOp slot, where binary operations like <code>+, -, *</code>, etc. can record feedback about the inputs and outputs that were seen so far.</li>
<li>Feedback vector of a specific closure can be seen by using <code>%DebugPrint()</code> function.</li>
<li>Feedback can only progress in latice, it&rsquo;s impossible to go back. If it go back then it&rsquo;ll risk entering deoptimization loop where optimizing compiler consumes feedback and bails out from optimized code, back to interpreter, whenever it sees values that don&rsquo;t agree with the feedback.</li>
<li>Checking if the value is Smi Representation and converting Smi to Word32
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-asm" data-lang="asm"><span style="color:#75715e"># Check if the value is small integer
</span><span style="color:#75715e"></span><span style="color:#a6e22e">movq</span> <span style="color:#66d9ef">rax</span>, [<span style="color:#66d9ef">rbp</span><span style="color:#960050;background-color:#1e0010">+</span><span style="color:#ae81ff">0x18</span>]
<span style="color:#a6e22e">test</span> <span style="color:#66d9ef">al</span>, <span style="color:#ae81ff">0x1</span>        <span style="color:#960050;background-color:#1e0010">//</span> <span style="color:#66d9ef">least</span> <span style="color:#66d9ef">significant</span> <span style="color:#66d9ef">bit</span> <span style="color:#66d9ef">should</span> <span style="color:#66d9ef">be</span> <span style="color:#ae81ff">0</span> <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">Smi.</span>
<span style="color:#a6e22e">jnz</span> <span style="color:#66d9ef">Deoptimize</span>      <span style="color:#960050;background-color:#1e0010">//</span> <span style="color:#66d9ef">if</span>(<span style="color:#66d9ef">al</span> !<span style="color:#960050;background-color:#1e0010">=</span> <span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">jnz</span> <span style="color:#66d9ef">Deoptmize</span>
<span style="color:#75715e"># convert from Smi to Word32
</span><span style="color:#75715e"></span><span style="color:#a6e22e">movq</span> <span style="color:#66d9ef">rcx</span>, <span style="color:#66d9ef">rax</span>
<span style="color:#a6e22e">shrq</span> <span style="color:#66d9ef">rcx</span>, <span style="color:#ae81ff">32</span>        <span style="color:#960050;background-color:#1e0010">//</span> <span style="color:#66d9ef">converting</span> <span style="color:#66d9ef">to</span> <span style="color:#ae81ff">32</span>-<span style="color:#66d9ef">bit</span> <span style="color:#66d9ef">representaion</span> <span style="color:#66d9ef">by</span> <span style="color:#66d9ef">shifting</span> <span style="color:#66d9ef">value</span> <span style="color:#66d9ef">by</span> <span style="color:#ae81ff">32</span> <span style="color:#66d9ef">bit</span> <span style="color:#66d9ef">to</span> <span style="color:#66d9ef">right</span>
</code></pre></div></li>
</ol>
<h4 id="sea-of-nodes">Sea of Nodes</h4>
<p>Turbofan works with <code>Sea of Nodes</code> and each nodes is indicates as part of graph. Nodes represents arithemetic operations, load, stores, calls, constants etc. Each node produces a value. Also each node points to its operand. For instance, 2+3=5. In this case the node points to 2 and 3.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#75715e">// A Node is the basic primitive of graphs. Nodes are chained together by
</span><span style="color:#75715e">// input/use chains but by default otherwise contain only an identifying number
</span><span style="color:#75715e">// which specific applications of graphs and nodes can use to index auxiliary
</span><span style="color:#75715e">// out-of-line data, especially transient data.
</span><span style="color:#75715e">//
</span><span style="color:#75715e">// In addition Nodes only contain a mutable Operator that may change during
</span><span style="color:#75715e">// compilation, e.g. during lowering passes. Other information that needs to be
</span><span style="color:#75715e">// associated with Nodes during compilation must be stored out-of-line indexed
</span><span style="color:#75715e">// by the Node&#39;s id.
</span><span style="color:#75715e"></span>
<span style="color:#75715e">// NodeIds are identifying numbers for nodes that can be used to index auxiliary
</span><span style="color:#75715e">// out-of-line data associated with each node.
</span></code></pre></div><p>Three types of edges are:</p>
<ol>
<li>Control edges
Control edges enables branches and loops.</li>
<li>Value edges
Value edges shows the value dependencies.</li>
<li>Effect edges
Effect edges order operations such as reading or writing states.
For instance:
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#a6e22e">ob</span>.<span style="color:#a6e22e">a</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">ob</span>.<span style="color:#a6e22e">a</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
</code></pre></div><p>In this example, before writing to property <code>a</code> we need to read the property <code>a</code> first. As a result, an effect edge exists between the load and the store. And also we have to increement the value of property <code>a</code> beforing storing it. On that account, there is a requirement for an effect edge between the load and the addition. So the effect edge make sure that load-&gt;add-&gt;store are organized in this sequence. Effect edge will only be shown in the graph if there is an operation that changes the state of the variable or the object in that program.
Another use of effect is, if the X node has an output effect to another node, the other node is informed that it cannot do anything until the X node has completed its work.</p>
</li>
</ol>
<h3 id="different-v8-phase">Different V8 phase</h3>
<h4 id="graph-builder-phase">Graph builder phase</h4>
<p>Graph builder is not as optimization phase but has the largest number of nodes. This is the first generate graph we can view this by selecting <code>bytecode graph builder</code> option in Turbolizer. Using the AST, it makes a graph of JavaScript nodes such as JSAdd, JSCallFunction, JSLoadProperty, IfTrue, IfFalse, etc.</p>
<h4 id="typer-phase">Typer phase</h4>
<p>After the Graph builder finished the graph creation then the optimization phases start. The early optimizatiohn phase is <code>TyperPhase</code> and is run by <code>OptimizeGraph</code>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#75715e">// src/compiler/pipeline.cc
</span><span style="color:#75715e"></span><span style="color:#66d9ef">bool</span> PipelineImpl<span style="color:#f92672">::</span>OptimizeGraph(Linkage<span style="color:#f92672">*</span> linkage) {
  PipelineData<span style="color:#f92672">*</span> data <span style="color:#f92672">=</span> <span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>data_;
  data<span style="color:#f92672">-&gt;</span>BeginPhaseKind(<span style="color:#e6db74">&#34;V8.TFLowering&#34;</span>);
  <span style="color:#75715e">// Type the graph and keep the Typer running such that new nodes get
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// automatically typed when they are created.
</span><span style="display:block;width:100%;background-color:#3c3d38"><span style="color:#75715e"></span>  Run<span style="color:#f92672">&lt;</span>TyperPhase<span style="color:#f92672">&gt;</span>(data<span style="color:#f92672">-&gt;</span>CreateTyper());
</span>  <span style="color:#75715e">// ...
</span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#75715e">// src/compiler/pipeline.cc
</span><span style="display:block;width:100%;background-color:#3c3d38"><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">TyperPhase</span> {
</span>  DECL_PIPELINE_PHASE_CONSTANTS(Typer)

  <span style="color:#66d9ef">void</span> Run(PipelineData<span style="color:#f92672">*</span> data, Zone<span style="color:#f92672">*</span> temp_zone, Typer<span style="color:#f92672">*</span> typer) {
    NodeVector <span style="color:#a6e22e">roots</span>(temp_zone);
    data<span style="color:#f92672">-&gt;</span>jsgraph()<span style="color:#f92672">-&gt;</span>GetCachedNodes(<span style="color:#f92672">&amp;</span>roots);

    <span style="color:#75715e">// Make sure we always type True and False. Needed for escape analysis.
</span><span style="color:#75715e"></span>    roots.push_back(data<span style="color:#f92672">-&gt;</span>jsgraph()<span style="color:#f92672">-&gt;</span>TrueConstant());
    roots.push_back(data<span style="color:#f92672">-&gt;</span>jsgraph()<span style="color:#f92672">-&gt;</span>FalseConstant());

    LoopVariableOptimizer <span style="color:#a6e22e">induction_vars</span>(data<span style="color:#f92672">-&gt;</span>jsgraph()<span style="color:#f92672">-&gt;</span>graph(),
                                         data<span style="color:#f92672">-&gt;</span>common(), temp_zone);
    <span style="color:#66d9ef">if</span> (FLAG_turbo_loop_variable) induction_vars.Run();

    <span style="color:#75715e">// The typer inspects heap objects, so we need to unpark the local heap.
</span><span style="color:#75715e"></span>    UnparkedScopeIfNeeded <span style="color:#a6e22e">scope</span>(data<span style="color:#f92672">-&gt;</span>broker());
<span style="display:block;width:100%;background-color:#3c3d38">    typer<span style="color:#f92672">-&gt;</span>Run(roots, <span style="color:#f92672">&amp;</span>induction_vars);
</span>  }
};
</code></pre></div><p>As we can see in the below code, when the typer runs it visits every node of the graph and then each node is passed inside the <code>graph_reducer.ReduceNode()</code> function to reduce them. There will be the seperate post for the GraphReducer.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#75715e">// src/compiler/typer.cc
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> Typer<span style="color:#f92672">::</span>Run(<span style="color:#66d9ef">const</span> NodeVector<span style="color:#f92672">&amp;</span> roots,
                LoopVariableOptimizer<span style="color:#f92672">*</span> induction_vars) {
  <span style="color:#75715e">// An induction variable is a variable whose value is derived from the loop iteration 
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// variable&#39;s value 
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// or in simple form,
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// variable that gets increased or decreased by a fixed amount on every iteration of a loop
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// It is often variable i in for loop
</span><span style="color:#75715e"></span>
  <span style="color:#66d9ef">if</span> (induction_vars <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nullptr</span>) {
    induction_vars<span style="color:#f92672">-&gt;</span>ChangeToInductionVariablePhis();
  }
  Visitor <span style="color:#a6e22e">visitor</span>(<span style="color:#66d9ef">this</span>, induction_vars);
  GraphReducer <span style="color:#a6e22e">graph_reducer</span>(zone(), graph(), tick_counter_, broker());
  graph_reducer.AddReducer(<span style="color:#f92672">&amp;</span>visitor);
  <span style="color:#66d9ef">for</span> (Node<span style="color:#f92672">*</span> <span style="color:#66d9ef">const</span> root : roots) graph_reducer.ReduceNode(root);
  graph_reducer.ReduceGraph();
  <span style="color:#75715e">// ...
</span><span style="color:#75715e"></span>}
</code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Typer</span><span style="color:#f92672">::</span>Visitor : <span style="color:#66d9ef">public</span> Reducer {
 <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
  <span style="color:#75715e">//  ...
</span><span style="color:#75715e"></span>  Reduction Reduce(Node<span style="color:#f92672">*</span> node) <span style="color:#66d9ef">override</span> {
    <span style="color:#66d9ef">if</span> (node<span style="color:#f92672">-&gt;</span>op()<span style="color:#f92672">-&gt;</span>ValueOutputCount() <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">return</span> NoChange();
    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">UpdateType</span>(node, TypeNode(node));
  }
  <span style="color:#75715e">//  ...
</span></code></pre></div><p>For instance, suppose the turbofan is optimised to compile and execute, in which case on every <code>JSCall</code> node visit, <code>TyperPhase</code> will call <code>JSCallTyper</code>, and so on. In the <code>JSCallTyper</code> we can see the switch state with large number of cases and most of builtin function is assigned with the associated <code>Type</code> which will be used to identify it. For instance, if the function call is builtin <code>MathRandom</code> the expected return type would be <code>Type::PlainNumber</code>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#75715e">// src/compiler/typer.cc
</span><span style="color:#75715e"></span>Type Typer<span style="color:#f92672">::</span>Visitor<span style="color:#f92672">::</span>JSCallTyper(Type fun, Typer<span style="color:#f92672">*</span> t) {
  <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>fun.IsHeapConstant() <span style="color:#f92672">||</span> <span style="color:#f92672">!</span>fun.AsHeapConstant()<span style="color:#f92672">-&gt;</span>Ref().IsJSFunction()) {
    <span style="color:#66d9ef">return</span> Type<span style="color:#f92672">::</span>NonInternal();
  }
  JSFunctionRef function <span style="color:#f92672">=</span> fun.AsHeapConstant()<span style="color:#f92672">-&gt;</span>Ref().AsJSFunction();
  <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>function.serialized()) {
    TRACE_BROKER_MISSING(t<span style="color:#f92672">-&gt;</span>broker(), <span style="color:#e6db74">&#34;data for function &#34;</span> <span style="color:#f92672">&lt;&lt;</span> function);
    <span style="color:#66d9ef">return</span> Type<span style="color:#f92672">::</span>NonInternal();
  }
  <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>function.shared().HasBuiltinId()) {
    <span style="color:#66d9ef">return</span> Type<span style="color:#f92672">::</span>NonInternal();
  }
<span style="display:block;width:100%;background-color:#3c3d38">  <span style="color:#66d9ef">switch</span> (function.shared().builtin_id()) {
</span><span style="display:block;width:100%;background-color:#3c3d38">    <span style="color:#66d9ef">case</span> Builtins<span style="color:#f92672">::</span>kMathRandom:
</span><span style="display:block;width:100%;background-color:#3c3d38">      <span style="color:#66d9ef">return</span> Type<span style="color:#f92672">::</span>PlainNumber();
</span>    <span style="color:#75715e">//  ...
</span></code></pre></div><p>For the node <code>NumberConstant</code> in most cases the the type will be Range.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++">Type Typer<span style="color:#f92672">::</span>Visitor<span style="color:#f92672">::</span>TypeNumberConstant(Node<span style="color:#f92672">*</span> node) {
  <span style="color:#66d9ef">double</span> number <span style="color:#f92672">=</span> OpParameter<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">double</span><span style="color:#f92672">&gt;</span>(node<span style="color:#f92672">-&gt;</span>op());
  <span style="color:#66d9ef">return</span> Type<span style="color:#f92672">::</span>Constant(number, zone());
}

Type Type<span style="color:#f92672">::</span>Constant(<span style="color:#66d9ef">double</span> value, Zone<span style="color:#f92672">*</span> zone) {
  <span style="color:#66d9ef">if</span> (RangeType<span style="color:#f92672">::</span>IsInteger(value)) {
    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">Range</span>(value, value, zone);
  } <span style="color:#66d9ef">else</span> <span style="color:#a6e22e">if</span> (IsMinusZero(value)) {
    <span style="color:#66d9ef">return</span> Type<span style="color:#f92672">::</span>MinusZero();
  } <span style="color:#66d9ef">else</span> <span style="color:#a6e22e">if</span> (std<span style="color:#f92672">::</span>isnan(value)) {
    <span style="color:#66d9ef">return</span> Type<span style="color:#f92672">::</span>NaN();
  }

  DCHECK(OtherNumberConstantType<span style="color:#f92672">::</span>IsOtherNumberConstant(value));
  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">OtherNumberConstant</span>(value, zone);
}
</code></pre></div><h4 id="type-lowering">Type Lowering</h4>
<p>This phase comes right after the typerphase in <code>OptimizeGraph</code>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#66d9ef">bool</span> PipelineImpl<span style="color:#f92672">::</span>OptimizeGraph(Linkage<span style="color:#f92672">*</span> linkage) {
  PipelineData<span style="color:#f92672">*</span> data <span style="color:#f92672">=</span> <span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>data_;
  data<span style="color:#f92672">-&gt;</span>BeginPhaseKind(<span style="color:#e6db74">&#34;V8.TFLowering&#34;</span>);
  Run<span style="color:#f92672">&lt;</span>TyperPhase<span style="color:#f92672">&gt;</span>(data<span style="color:#f92672">-&gt;</span>CreateTyper());
  RunPrintAndVerify(TyperPhase<span style="color:#f92672">::</span>phase_name());
<span style="display:block;width:100%;background-color:#3c3d38">  Run<span style="color:#f92672">&lt;</span>TypedLoweringPhase<span style="color:#f92672">&gt;</span>();
</span>  RunPrintAndVerify(TypedLoweringPhase<span style="color:#f92672">::</span>phase_name());
</code></pre></div><p>There are more reducer in this Phase.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">TypedLoweringPhase</span> {
  DECL_PIPELINE_PHASE_CONSTANTS(TypedLowering)

  <span style="color:#66d9ef">void</span> Run(PipelineData<span style="color:#f92672">*</span> data, Zone<span style="color:#f92672">*</span> temp_zone) {
    <span style="color:#75715e">// ...
</span><span style="color:#75715e"></span>    AddReducer(data, <span style="color:#f92672">&amp;</span>graph_reducer, <span style="color:#f92672">&amp;</span>dead_code_elimination);

    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>data<span style="color:#f92672">-&gt;</span>info()<span style="color:#f92672">-&gt;</span>IsNativeContextIndependent()) {
      AddReducer(data, <span style="color:#f92672">&amp;</span>graph_reducer, <span style="color:#f92672">&amp;</span>create_lowering);
    }
    AddReducer(data, <span style="color:#f92672">&amp;</span>graph_reducer, <span style="color:#f92672">&amp;</span>constant_folding_reducer);
    AddReducer(data, <span style="color:#f92672">&amp;</span>graph_reducer, <span style="color:#f92672">&amp;</span>typed_lowering);
    AddReducer(data, <span style="color:#f92672">&amp;</span>graph_reducer, <span style="color:#f92672">&amp;</span>typed_optimization);
    AddReducer(data, <span style="color:#f92672">&amp;</span>graph_reducer, <span style="color:#f92672">&amp;</span>simple_reducer);
    AddReducer(data, <span style="color:#f92672">&amp;</span>graph_reducer, <span style="color:#f92672">&amp;</span>checkpoint_elimination);
    AddReducer(data, <span style="color:#f92672">&amp;</span>graph_reducer, <span style="color:#f92672">&amp;</span>common_reducer);
    <span style="color:#75715e">// ...
</span><span style="color:#75715e"></span>  }
};

<span style="color:#75715e">// AddReducer Function
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">AddReducer</span>(PipelineData<span style="color:#f92672">*</span> data, GraphReducer<span style="color:#f92672">*</span> graph_reducer,
                Reducer<span style="color:#f92672">*</span> reducer) {
  <span style="color:#66d9ef">if</span> (data<span style="color:#f92672">-&gt;</span>info()<span style="color:#f92672">-&gt;</span>source_positions()) {
    SourcePositionWrapper<span style="color:#f92672">*</span> <span style="color:#66d9ef">const</span> wrapper <span style="color:#f92672">=</span>
        data<span style="color:#f92672">-&gt;</span>graph_zone()<span style="color:#f92672">-&gt;</span>New<span style="color:#f92672">&lt;</span>SourcePositionWrapper<span style="color:#f92672">&gt;</span>(
            reducer, data<span style="color:#f92672">-&gt;</span>source_positions());
    reducer <span style="color:#f92672">=</span> wrapper;
  }
  <span style="color:#66d9ef">if</span> (data<span style="color:#f92672">-&gt;</span>info()<span style="color:#f92672">-&gt;</span>trace_turbo_json()) {
    NodeOriginsWrapper<span style="color:#f92672">*</span> <span style="color:#66d9ef">const</span> wrapper <span style="color:#f92672">=</span>
        data<span style="color:#f92672">-&gt;</span>graph_zone()<span style="color:#f92672">-&gt;</span>New<span style="color:#f92672">&lt;</span>NodeOriginsWrapper<span style="color:#f92672">&gt;</span>(reducer,
                                                    data<span style="color:#f92672">-&gt;</span>node_origins());
    reducer <span style="color:#f92672">=</span> wrapper;
  }

  graph_reducer<span style="color:#f92672">-&gt;</span>AddReducer(reducer);
}

</code></pre></div><p>For feneral understanding purpose we&rsquo;ll inspect the <code>TypedOptimization</code> reducer. We&rsquo;ll look at code inside <code>TypedOptimization::Reduce</code>. We can see there is a switch statement with huge number of cases, for instance, if the visited node&rsquo;s <code>opcode()</code> is <code>kSpeculativeNumberAdd</code> it&rsquo;ll call <code>ReduceSpeculativeNumberAdd(node)</code> function.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++">Reduction TypedOptimization<span style="color:#f92672">::</span>Reduce(Node<span style="color:#f92672">*</span> node) {
  DisallowHeapAccessIf <span style="color:#a6e22e">no_heap_access</span>(<span style="color:#f92672">!</span>FLAG_turbo_direct_heap_access);
  <span style="color:#66d9ef">switch</span> (node<span style="color:#f92672">-&gt;</span>opcode()) {
    <span style="color:#66d9ef">case</span> IrOpcode<span style="color:#f92672">::</span>kConvertReceiver:
      <span style="color:#66d9ef">return</span> ReduceConvertReceiver(node);
    <span style="color:#66d9ef">case</span> IrOpcode<span style="color:#f92672">::</span>kMaybeGrowFastElements:
      <span style="color:#66d9ef">return</span> ReduceMaybeGrowFastElements(node);
    <span style="color:#66d9ef">case</span> IrOpcode<span style="color:#f92672">::</span>kCheckHeapObject:
      <span style="color:#66d9ef">return</span> ReduceCheckHeapObject(node);
    <span style="color:#75715e">// ...
</span><span style="display:block;width:100%;background-color:#3c3d38"><span style="color:#75715e"></span>    <span style="color:#66d9ef">case</span> IrOpcode<span style="color:#f92672">::</span>kSpeculativeNumberAdd:
</span><span style="display:block;width:100%;background-color:#3c3d38">      <span style="color:#66d9ef">return</span> ReduceSpeculativeNumberAdd(node);
</span>    <span style="color:#75715e">// ...
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">default</span><span style="color:#f92672">:</span>
      <span style="color:#66d9ef">break</span>;
  }
  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">NoChange</span>();
}
<span style="color:#75715e">// ReduceSpeculativeNumberAdd Function
</span><span style="color:#75715e"></span>Reduction TypedOptimization<span style="color:#f92672">::</span>ReduceSpeculativeNumberAdd(Node<span style="color:#f92672">*</span> node) {
  Node<span style="color:#f92672">*</span> <span style="color:#66d9ef">const</span> lhs <span style="color:#f92672">=</span> NodeProperties<span style="color:#f92672">::</span>GetValueInput(node, <span style="color:#ae81ff">0</span>);
  Node<span style="color:#f92672">*</span> <span style="color:#66d9ef">const</span> rhs <span style="color:#f92672">=</span> NodeProperties<span style="color:#f92672">::</span>GetValueInput(node, <span style="color:#ae81ff">1</span>);
  Type <span style="color:#66d9ef">const</span> lhs_type <span style="color:#f92672">=</span> NodeProperties<span style="color:#f92672">::</span>GetType(lhs);
  Type <span style="color:#66d9ef">const</span> rhs_type <span style="color:#f92672">=</span> NodeProperties<span style="color:#f92672">::</span>GetType(rhs);
  NumberOperationHint hint <span style="color:#f92672">=</span> NumberOperationHintOf(node<span style="color:#f92672">-&gt;</span>op());
  <span style="color:#66d9ef">if</span> ((hint <span style="color:#f92672">==</span> NumberOperationHint<span style="color:#f92672">::</span>kNumber <span style="color:#f92672">||</span>
       hint <span style="color:#f92672">==</span> NumberOperationHint<span style="color:#f92672">::</span>kNumberOrOddball) <span style="color:#f92672">&amp;&amp;</span>
      BothAre(lhs_type, rhs_type, Type<span style="color:#f92672">::</span>PlainPrimitive()) <span style="color:#f92672">&amp;&amp;</span>
      NeitherCanBe(lhs_type, rhs_type, Type<span style="color:#f92672">::</span>StringOrReceiver())) {
    <span style="color:#75715e">// SpeculativeNumberAdd(x:-string, y:-string) =&gt;
</span><span style="color:#75715e"></span>    <span style="color:#75715e">//     NumberAdd(ToNumber(x), ToNumber(y))
</span><span style="color:#75715e"></span>    Node<span style="color:#f92672">*</span> <span style="color:#66d9ef">const</span> toNum_lhs <span style="color:#f92672">=</span> ConvertPlainPrimitiveToNumber(lhs);
    Node<span style="color:#f92672">*</span> <span style="color:#66d9ef">const</span> toNum_rhs <span style="color:#f92672">=</span> ConvertPlainPrimitiveToNumber(rhs);
    Node<span style="color:#f92672">*</span> <span style="color:#66d9ef">const</span> value <span style="color:#f92672">=</span>
        graph()<span style="color:#f92672">-&gt;</span>NewNode(simplified()<span style="color:#f92672">-&gt;</span>NumberAdd(), toNum_lhs, toNum_rhs);
    ReplaceWithValue(node, value);
    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">Replace</span>(value);
  }
  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">NoChange</span>();
}
</code></pre></div><p>In <code>ReduceSpeculativeNumberAdd</code> function if both <code>lhs and rhs</code> Node has hint of <code>NumberOperationHint::kNumber</code> and both the <code>lhs_type and rhs_type</code> are <code>Type::PlainPrimitive</code> the <code>SpeculativeNumberAdd</code> function will be replaced by the <code>NumberAdd</code>.</p>
<p>Also, in <code>JSTypedLowering::ReduceJSCall</code> when <code>JSTypedLowering</code> reducer visits the <code>JSCall</code> node, turbo fan simply creates a <code>LoadField</code> node and replace opcode of the <code>JSCall</code> node to <code>Call</code> opcode.
<code>ChangeOp</code> means change opcode.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++">Reduction JSTypedLowering<span style="color:#f92672">::</span>ReduceJSCall(Node<span style="color:#f92672">*</span> node) {
    <span style="color:#75715e">// [...]
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// Load the context from the {target}.
</span><span style="display:block;width:100%;background-color:#3c3d38"><span style="color:#75715e"></span>    Node<span style="color:#f92672">*</span> context <span style="color:#f92672">=</span> effect <span style="color:#f92672">=</span> graph()<span style="color:#f92672">-&gt;</span>NewNode(
</span><span style="display:block;width:100%;background-color:#3c3d38">        simplified()<span style="color:#f92672">-&gt;</span>LoadField(AccessBuilder<span style="color:#f92672">::</span>ForJSFunctionContext()), target,
</span><span style="display:block;width:100%;background-color:#3c3d38">        effect, control);
</span><span style="display:block;width:100%;background-color:#3c3d38">    NodeProperties<span style="color:#f92672">::</span>ReplaceContextInput(node, context);
</span>
    <span style="color:#75715e">// Update the effect dependency for the {node}.
</span><span style="color:#75715e"></span>    NodeProperties<span style="color:#f92672">::</span>ReplaceEffectInput(node, effect);

    <span style="color:#75715e">// [...]
</span><span style="color:#75715e"></span>    } <span style="color:#66d9ef">else</span> <span style="color:#a6e22e">if</span> (shared<span style="color:#f92672">-&gt;</span>HasBuiltinId()) {
      DCHECK(Builtins<span style="color:#f92672">::</span>HasJSLinkage(shared<span style="color:#f92672">-&gt;</span>builtin_id()));
      <span style="color:#75715e">// Patch {node} to a direct code object call.
</span><span style="color:#75715e"></span>      Callable callable <span style="color:#f92672">=</span> Builtins<span style="color:#f92672">::</span>CallableFor(
          isolate(), <span style="color:#66d9ef">static_cast</span><span style="color:#f92672">&lt;</span>Builtins<span style="color:#f92672">::</span>Name<span style="color:#f92672">&gt;</span>(shared<span style="color:#f92672">-&gt;</span>builtin_id()));
      CallDescriptor<span style="color:#f92672">::</span>Flags flags <span style="color:#f92672">=</span> CallDescriptor<span style="color:#f92672">::</span>kNeedsFrameState;

      <span style="color:#66d9ef">const</span> CallInterfaceDescriptor<span style="color:#f92672">&amp;</span> descriptor <span style="color:#f92672">=</span> callable.descriptor();
      <span style="color:#66d9ef">auto</span> call_descriptor <span style="color:#f92672">=</span> Linkage<span style="color:#f92672">::</span>GetStubCallDescriptor(
          graph()<span style="color:#f92672">-&gt;</span>zone(), descriptor, <span style="color:#ae81ff">1</span> <span style="color:#f92672">+</span> arity, flags);
      Node<span style="color:#f92672">*</span> stub_code <span style="color:#f92672">=</span> jsgraph()<span style="color:#f92672">-&gt;</span>HeapConstant(callable.code());
      node<span style="color:#f92672">-&gt;</span>RemoveInput(n.FeedbackVectorIndex());
      node<span style="color:#f92672">-&gt;</span>InsertInput(graph()<span style="color:#f92672">-&gt;</span>zone(), <span style="color:#ae81ff">0</span>, stub_code);  <span style="color:#75715e">// Code object.
</span><span style="color:#75715e"></span>      node<span style="color:#f92672">-&gt;</span>InsertInput(graph()<span style="color:#f92672">-&gt;</span>zone(), <span style="color:#ae81ff">2</span>, new_target);
      node<span style="color:#f92672">-&gt;</span>InsertInput(graph()<span style="color:#f92672">-&gt;</span>zone(), <span style="color:#ae81ff">3</span>, jsgraph()<span style="color:#f92672">-&gt;</span>Constant(arity));
<span style="display:block;width:100%;background-color:#3c3d38">      NodeProperties<span style="color:#f92672">::</span>ChangeOp(node, common()<span style="color:#f92672">-&gt;</span>Call(call_descriptor));
</span>    }
    <span style="color:#75715e">// [...]
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">Changed</span>(node);
  }
</code></pre></div><h3 id="range-types">Range Types</h3>
<p>Sample code from <code>doar-e.github.io</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-JS" data-lang="JS"><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">opt_me</span>(<span style="color:#a6e22e">b</span>) {
  <span style="color:#66d9ef">let</span> <span style="color:#a6e22e">x</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>; <span style="color:#75715e">// [1] x0 = 10
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">b</span> <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;foo&#34;</span>)
    <span style="color:#a6e22e">x</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">5</span>; <span style="color:#75715e">// [2] x1 = 5
</span><span style="color:#75715e"></span>  
  <span style="color:#66d9ef">let</span> <span style="color:#a6e22e">y</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">x</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">2</span>; <span style="color:#75715e">// [3] x2 = phi(x0, x1)
</span><span style="color:#75715e"></span>  <span style="color:#a6e22e">y</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">y</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1000</span>; 
  <span style="color:#a6e22e">y</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">y</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">2</span>;
  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">y</span>;
}
</code></pre></div><p><code>SSA is a property of IR (intermediate representation)</code>.</p>
<p>In the above sample code, when the <code>opt_me</code> function is called initially <code>x</code> is set to <code>10</code>. If the parameter <code>b</code> is equal to <code>foo</code> then the value of <code>x</code> will be set to <code>5</code>. So depending on the <code>if</code> statement <code>x</code> value wiil be either 10 or 5. However, in SSA <code>(Static Single Assignment)</code> each variable must me assigned exactly once. So for each value 10 and 5, x0 and x1 will be created respectively. As a result <code>phi</code> function is needed at line no [3] because <code>x</code> must be either <code>x0</code> or <code>x1</code>. At line no [3], <code>x2 = phi(x0,x1)</code> statement is commented. This statement tells that the <code>x2</code> can take only one value either <code>x0 or x1</code>.
In addition, the type of the constant value <code>10 (x0)</code> is <code>Range(10,10)</code> and the range of the constant value <code>5 (X1)</code> is <code>Range(5,5)</code> so the type of the <code>phi</code> is union of thow ranges i.e., <code>Range(5,10)</code>.</p>
<p>Let&rsquo;s inspect this in much details by looking at the code.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++">Type Typer<span style="color:#f92672">::</span>Visitor<span style="color:#f92672">::</span>TypePhi(Node<span style="color:#f92672">*</span> node) {
  <span style="color:#75715e">// arity is number of argument or operand taken by the function or operation
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">int</span> arity <span style="color:#f92672">=</span> node<span style="color:#f92672">-&gt;</span>op()<span style="color:#f92672">-&gt;</span>ValueInputCount();
  Type type <span style="color:#f92672">=</span> Operand(node, <span style="color:#ae81ff">0</span>);
  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span> arity; <span style="color:#f92672">++</span>i) {
    type <span style="color:#f92672">=</span> Type<span style="color:#f92672">::</span>Union(type, Operand(node, i), zone());
  }
  <span style="color:#66d9ef">return</span> type;
}
</code></pre></div><p>In the above code, it just unions the Type of Node with all of the Types of Operand and returns the result.</p>
<p>Lets Inspect the typing of the <code>SpeculativeSafeIntegerAdd</code> nodes. This is implemented in <code>OperationTyper</code>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++">Type OperationTyper<span style="color:#f92672">::</span>SpeculativeSafeIntegerAdd(Type lhs, Type rhs) {
  Type result <span style="color:#f92672">=</span> SpeculativeNumberAdd(lhs, rhs);

  <span style="color:#75715e">// If we have a Smi or Int32 feedback, the representation selection will
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// either truncate or it will check the inputs (i.e., deopt if not int32).
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// In either case the result will be in the safe integer range, so we
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// can bake in the type here. This needs to be in sync with
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// SimplifiedLowering::VisitSpeculativeAdditiveOp.
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">return</span> Type<span style="color:#f92672">::</span>Intersect(result, cache_<span style="color:#f92672">-&gt;</span>kSafeIntegerOrMinusZero, zone());
}
</code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#75715e">// In case of NumberAdd, return Name(lhs,rhs) turns into
</span><span style="color:#75715e">// NumberAdd(lhs, rhs)
</span><span style="color:#75715e"></span><span style="color:#75715e">#define SPECULATIVE_NUMBER_BINOP(Name)                         \
</span><span style="color:#75715e">  Type OperationTyper::Speculative##Name(Type lhs, Type rhs) { \
</span><span style="color:#75715e">    lhs = SpeculativeToNumber(lhs);                            \
</span><span style="color:#75715e">    rhs = SpeculativeToNumber(rhs);                            \
</span><span style="color:#75715e">    return Name(lhs, rhs);                                     \
</span><span style="color:#75715e">  }
</span><span style="color:#75715e"></span>
  SPECULATIVE_NUMBER_BINOP(NumberAdd)
</code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#75715e">// src/compiler/operation-typer.cc
</span><span style="color:#75715e">// Actual Number Add function
</span><span style="color:#75715e"></span>Type OperationTyper<span style="color:#f92672">::</span>NumberAdd(Type lhs, Type rhs) {
  <span style="color:#75715e">// [...]
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// We can give more precise types for integers.
</span><span style="color:#75715e"></span>  Type type <span style="color:#f92672">=</span> Type<span style="color:#f92672">::</span>None();
  lhs <span style="color:#f92672">=</span> Type<span style="color:#f92672">::</span>Intersect(lhs, Type<span style="color:#f92672">::</span>PlainNumber(), zone());
  rhs <span style="color:#f92672">=</span> Type<span style="color:#f92672">::</span>Intersect(rhs, Type<span style="color:#f92672">::</span>PlainNumber(), zone());
  <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>lhs.IsNone() <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!</span>rhs.IsNone()) {
    <span style="color:#66d9ef">if</span> (lhs.Is(cache_<span style="color:#f92672">-&gt;</span>kInteger) <span style="color:#f92672">&amp;&amp;</span> rhs.Is(cache_<span style="color:#f92672">-&gt;</span>kInteger)) {
<span style="display:block;width:100%;background-color:#3c3d38">      type <span style="color:#f92672">=</span> AddRanger(lhs.Min(), lhs.Max(), rhs.Min(), rhs.Max());
</span>    } 
  <span style="color:#75715e">// [...]
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// Take into account the -0 and NaN information computed earlier.
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">if</span> (maybe_minuszero) type <span style="color:#f92672">=</span> Type<span style="color:#f92672">::</span>Union(type, Type<span style="color:#f92672">::</span>MinusZero(), zone());
  <span style="color:#66d9ef">if</span> (maybe_nan) type <span style="color:#f92672">=</span> Type<span style="color:#f92672">::</span>Union(type, Type<span style="color:#f92672">::</span>NaN(), zone());
  <span style="color:#66d9ef">return</span> type;
}

</code></pre></div><p><code>AddRanger</code> function calculates the min and max bound of <code>Range</code>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++">Type OperationTyper<span style="color:#f92672">::</span>AddRanger(<span style="color:#66d9ef">double</span> lhs_min, <span style="color:#66d9ef">double</span> lhs_max, <span style="color:#66d9ef">double</span> rhs_min,
                               <span style="color:#66d9ef">double</span> rhs_max) {
  <span style="color:#75715e">// lhs = (5,10)
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// rhs = (2,3)
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// lhs_min = 5, lhs_max = 10
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// rhs_min = 2, rhs_max = 3
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">double</span> results[<span style="color:#ae81ff">4</span>];
  results[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> lhs_min <span style="color:#f92672">+</span> rhs_min; <span style="color:#75715e">// 5 + 2 = 7
</span><span style="color:#75715e"></span>  results[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> lhs_min <span style="color:#f92672">+</span> rhs_max; <span style="color:#75715e">// 5 + 3 = 8
</span><span style="color:#75715e"></span>  results[<span style="color:#ae81ff">2</span>] <span style="color:#f92672">=</span> lhs_max <span style="color:#f92672">+</span> rhs_min; <span style="color:#75715e">// 10 + 2 = 12
</span><span style="color:#75715e"></span>  results[<span style="color:#ae81ff">3</span>] <span style="color:#f92672">=</span> lhs_max <span style="color:#f92672">+</span> rhs_max; <span style="color:#75715e">// 10 + 3 = 13
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// Since none of the inputs can be -0, the result cannot be -0 either.
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// However, it can be nan (the sum of two infinities of opposite sign).
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// On the other hand, if none of the &#34;results&#34; above is nan, then the
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// actual result cannot be nan either.
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">int</span> nans <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">4</span>; <span style="color:#f92672">++</span>i) {
    <span style="color:#66d9ef">if</span> (std<span style="color:#f92672">::</span>isnan(results[i])) <span style="color:#f92672">++</span>nans;
  }
  <span style="color:#66d9ef">if</span> (nans <span style="color:#f92672">==</span> <span style="color:#ae81ff">4</span>) <span style="color:#66d9ef">return</span> Type<span style="color:#f92672">::</span>NaN();
  <span style="color:#75715e">// array_min = 7, array_max = 13
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// Range(7, 13)
</span><span style="color:#75715e"></span>  Type type <span style="color:#f92672">=</span> Type<span style="color:#f92672">::</span>Range(array_min(results, <span style="color:#ae81ff">4</span>), array_max(results, <span style="color:#ae81ff">4</span>), zone());
  <span style="color:#66d9ef">if</span> (nans <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>) type <span style="color:#f92672">=</span> Type<span style="color:#f92672">::</span>Union(type, Type<span style="color:#f92672">::</span>NaN(), zone());
  <span style="color:#75715e">// Examples:
</span><span style="color:#75715e"></span>  <span style="color:#75715e">//   [-inf, -inf] + [+inf, +inf] = NaN
</span><span style="color:#75715e"></span>  <span style="color:#75715e">//   [-inf, -inf] + [n, +inf] = [-inf, -inf] \/ NaN
</span><span style="color:#75715e"></span>  <span style="color:#75715e">//   [-inf, +inf] + [n, +inf] = [-inf, +inf] \/ NaN
</span><span style="color:#75715e"></span>  <span style="color:#75715e">//   [-inf, m] + [n, +inf] = [-inf, +inf] \/ NaN
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">return</span> type;
}
</code></pre></div><h4 id="checkbounds-nodes">CheckBounds nodes</h4>
<ol>
<li>To prevent array from accessing index out of range checkbound is added.</li>
<li>CheckBounds simply compares the input edge 0 (index) and input edge 1 (length), and make sure that the index is less than length.</li>
</ol>
<h4 id="simplified-lowering">Simplified Lowering</h4>
<p>In Simplified lowering while visiting the node (<code>VisitNode</code>), there is a switch statement with huge number of cases. In case of <code>CheckBounds</code> if the opcode of the node is <code>IrOpcode::kCheckBounds</code> then it&rsquo;ll call the function <code>VisitCheckBounds</code>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#75715e">// Dispatching routine for visiting the node {node} with the usage {use}.
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// Depending on the operator, propagate new usage info to the inputs.
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span>Phase T<span style="color:#f92672">&gt;</span>
  <span style="color:#66d9ef">void</span> VisitNode(Node<span style="color:#f92672">*</span> node, Truncation truncation,
                 SimplifiedLowering<span style="color:#f92672">*</span> lowering) {
    tick_counter_<span style="color:#f92672">-&gt;</span>TickAndMaybeEnterSafepoint();

    <span style="color:#75715e">// Unconditionally eliminate unused pure nodes (only relevant if there&#39;s
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// a pure operation in between two effectful ones, where the last one
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// is unused).
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// Note: We must not do this for constants, as they are cached and we
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// would thus kill the cached {node} during lowering (i.e. replace all
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// uses with Dead), but at that point some node lowering might have
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// already taken the constant {node} from the cache (while it was not
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// yet killed) and we would afterwards replace that use with Dead as well.
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (node<span style="color:#f92672">-&gt;</span>op()<span style="color:#f92672">-&gt;</span>ValueInputCount() <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span>
        node<span style="color:#f92672">-&gt;</span>op()<span style="color:#f92672">-&gt;</span>HasProperty(Operator<span style="color:#f92672">::</span>kPure) <span style="color:#f92672">&amp;&amp;</span> truncation.IsUnused()) {
      <span style="color:#66d9ef">return</span> VisitUnused<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>(node);
    }

    <span style="color:#66d9ef">if</span> (lower<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>()) InsertUnreachableIfNecessary<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>(node);

    <span style="color:#66d9ef">switch</span> (node<span style="color:#f92672">-&gt;</span>opcode()) {
      <span style="color:#75715e">//------------------------------------------------------------------
</span><span style="color:#75715e"></span>      <span style="color:#75715e">// Common operators.
</span><span style="color:#75715e"></span>      <span style="color:#75715e">//------------------------------------------------------------------
</span><span style="color:#75715e"></span>      <span style="color:#66d9ef">case</span> IrOpcode<span style="color:#f92672">::</span>kStart:
        <span style="color:#75715e">// We use Start as a terminator for the frame state chain, so even
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// tho Start doesn&#39;t really produce a value, we have to say Tagged
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// here, otherwise the input conversion will fail.
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> VisitLeaf<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>(node, MachineRepresentation<span style="color:#f92672">::</span>kTagged);
      <span style="color:#75715e">// [...]
</span><span style="display:block;width:100%;background-color:#3c3d38"><span style="color:#75715e"></span>      <span style="color:#66d9ef">case</span> IrOpcode<span style="color:#f92672">::</span>kCheckBounds:
</span><span style="display:block;width:100%;background-color:#3c3d38">        <span style="color:#66d9ef">return</span> VisitCheckBounds<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>(node, lowering);
</span>      <span style="color:#75715e">// [...]
</span></code></pre></div><p>As we can see in the <code>VisitCheckBounds</code>, <code>index_type</code> is type of input edge 0 and <code>length_type</code> is type of input edge 1. Also, if the minimum value of <code>index_type</code> is greater or equal to <code>0.0</code> and maximum of <code>index_type</code> is less than the minimum value of <code>length_type</code> the <code>new_flags</code> will set to <code>CheckBoundsFlags::kAbortOnOutOfBounds</code>. Which means the checkbound is not eliminated and the <code>opcode</code> of the node is changed into <code>CheckedUint32Bounds</code>. Search <code>kCheckUint32Bounds</code> for more details.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++">  <span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span>Phase T<span style="color:#f92672">&gt;</span>
  <span style="color:#66d9ef">void</span> VisitCheckBounds(Node<span style="color:#f92672">*</span> node, SimplifiedLowering<span style="color:#f92672">*</span> lowering) {
    CheckBoundsParameters <span style="color:#66d9ef">const</span><span style="color:#f92672">&amp;</span> p <span style="color:#f92672">=</span> CheckBoundsParametersOf(node<span style="color:#f92672">-&gt;</span>op());
    FeedbackSource <span style="color:#66d9ef">const</span><span style="color:#f92672">&amp;</span> feedback <span style="color:#f92672">=</span> p.check_parameters().feedback();
    Type <span style="color:#66d9ef">const</span> index_type <span style="color:#f92672">=</span> TypeOf(node<span style="color:#f92672">-&gt;</span>InputAt(<span style="color:#ae81ff">0</span>));
    Type <span style="color:#66d9ef">const</span> length_type <span style="color:#f92672">=</span> TypeOf(node<span style="color:#f92672">-&gt;</span>InputAt(<span style="color:#ae81ff">1</span>));

    <span style="color:#75715e">// Conversions, if requested and needed, will be handled by the
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// representation changer, not by the lower-level Checked*Bounds operators.
</span><span style="color:#75715e"></span>    CheckBoundsFlags new_flags <span style="color:#f92672">=</span>
        p.flags().without(CheckBoundsFlag<span style="color:#f92672">::</span>kConvertStringAndMinusZero);

    <span style="color:#66d9ef">if</span> (length_type.Is(Type<span style="color:#f92672">::</span>Unsigned31())) {
      <span style="color:#66d9ef">if</span> (index_type.Is(Type<span style="color:#f92672">::</span>Integral32()) <span style="color:#f92672">||</span>
          (index_type.Is(Type<span style="color:#f92672">::</span>Integral32OrMinusZero()) <span style="color:#f92672">&amp;&amp;</span>
           p.flags() <span style="color:#f92672">&amp;</span> CheckBoundsFlag<span style="color:#f92672">::</span>kConvertStringAndMinusZero)) {
        <span style="color:#75715e">// Map the values in the [-2^31,-1] range to the [2^31,2^32-1] range,
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// which will be considered out-of-bounds because the {length_type} is
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// limited to Unsigned31. This also converts -0 to 0.
</span><span style="color:#75715e"></span>        VisitBinop<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>(node, UseInfo<span style="color:#f92672">::</span>TruncatingWord32(),
                      MachineRepresentation<span style="color:#f92672">::</span>kWord32);
        <span style="color:#66d9ef">if</span> (lower<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>()) {
          <span style="color:#66d9ef">if</span> (lowering<span style="color:#f92672">-&gt;</span>poisoning_level_ <span style="color:#f92672">==</span>
                  PoisoningMitigationLevel<span style="color:#f92672">::</span>kDontPoison <span style="color:#f92672">&amp;&amp;</span>
              (index_type.IsNone() <span style="color:#f92672">||</span> length_type.IsNone() <span style="color:#f92672">||</span>
               (index_type.Min() <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0.0</span> <span style="color:#f92672">&amp;&amp;</span>
                index_type.Max() <span style="color:#f92672">&lt;</span> length_type.Min()))) {
            <span style="color:#75715e">// The bounds check is redundant if we already know that
</span><span style="color:#75715e"></span>            <span style="color:#75715e">// the index is within the bounds of [0.0, length[.
</span><span style="color:#75715e"></span>            <span style="color:#75715e">// TODO(neis): Move this into TypedOptimization?
</span><span style="color:#75715e"></span>            new_flags <span style="color:#f92672">|=</span> CheckBoundsFlag<span style="color:#f92672">::</span>kAbortOnOutOfBounds;
          }
          ChangeOp(node,
                   simplified()<span style="color:#f92672">-&gt;</span>CheckedUint32Bounds(feedback, new_flags));
        }
      }
      <span style="color:#75715e">// [...]
</span><span style="color:#75715e"></span>  }
</code></pre></div><p>In the <code>EffectControlLinearizer::LowerCheckedUint32Bounds</code>, it&rsquo;ll lower <code>CheckBounds</code> to the <code>Uint32LessThan</code>. <code>kDeoptOnOutOfBounds</code> will determine whether or not to determine whether the overflow deopt; There is if else statement in the following code, if the <code>params.flags()</code> is not <code>CheckBoundsFlag::kAbortOnOutOfBounds</code> it&rsquo;ll call <code>DeoptimizeIfNot</code> which basically <code>deoptimizes</code> except if the DeoptimizeReason is <code>kOutOfBounds</code> i.e., no deoptimization in case of out-of-bound. Instead it&rsquo;ll reach to unrechable node.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#75715e">// src/compiler/effect-control-linearizer.cc
</span><span style="color:#75715e"></span>Node<span style="color:#f92672">*</span> EffectControlLinearizer<span style="color:#f92672">::</span>LowerCheckedUint32Bounds(Node<span style="color:#f92672">*</span> node,
                                                        Node<span style="color:#f92672">*</span> frame_state) {
  Node<span style="color:#f92672">*</span> index <span style="color:#f92672">=</span> node<span style="color:#f92672">-&gt;</span>InputAt(<span style="color:#ae81ff">0</span>);
  Node<span style="color:#f92672">*</span> limit <span style="color:#f92672">=</span> node<span style="color:#f92672">-&gt;</span>InputAt(<span style="color:#ae81ff">1</span>);
  <span style="color:#66d9ef">const</span> CheckBoundsParameters<span style="color:#f92672">&amp;</span> params <span style="color:#f92672">=</span> CheckBoundsParametersOf(node<span style="color:#f92672">-&gt;</span>op());

  Node<span style="color:#f92672">*</span> check <span style="color:#f92672">=</span> __ Uint32LessThan(index, limit);
  <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>(params.flags() <span style="color:#f92672">&amp;</span> CheckBoundsFlag<span style="color:#f92672">::</span>kAbortOnOutOfBounds)) {
    __ <span style="color:#a6e22e">DeoptimizeIfNot</span>(DeoptimizeReason<span style="color:#f92672">::</span>kOutOfBounds,
                       params.check_parameters().feedback(), check, frame_state,
                       IsSafetyCheck<span style="color:#f92672">::</span>kCriticalSafetyCheck);
  } <span style="color:#66d9ef">else</span> {
    <span style="color:#66d9ef">auto</span> if_abort <span style="color:#f92672">=</span> __ MakeDeferredLabel();
    <span style="color:#66d9ef">auto</span> done <span style="color:#f92672">=</span> __ MakeLabel();

    __ <span style="color:#a6e22e">Branch</span>(check, <span style="color:#f92672">&amp;</span>done, <span style="color:#f92672">&amp;</span>if_abort);

    __ <span style="color:#a6e22e">Bind</span>(<span style="color:#f92672">&amp;</span>if_abort);
    __ <span style="color:#a6e22e">Unreachable</span>(<span style="color:#f92672">&amp;</span>done);

    __ <span style="color:#a6e22e">Bind</span>(<span style="color:#f92672">&amp;</span>done);
  }

  <span style="color:#66d9ef">return</span> index;
}
</code></pre></div><p>During instruction selection Unreachable nodes are replaced by breakpoint opcodes.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#75715e">// src/compiler/backend/instruction-selector.cc
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> InstructionSelector<span style="color:#f92672">::</span>VisitUnreachable(Node<span style="color:#f92672">*</span> node) {
  OperandGenerator <span style="color:#a6e22e">g</span>(<span style="color:#66d9ef">this</span>);
  Emit(kArchDebugBreak, g.NoOutput());
}

<span style="color:#75715e">// Emit function
</span><span style="color:#75715e"></span>Instruction<span style="color:#f92672">*</span> InstructionSelector<span style="color:#f92672">::</span>Emit(
    InstructionCode opcode, size_t output_count, InstructionOperand<span style="color:#f92672">*</span> outputs,
    size_t input_count, InstructionOperand<span style="color:#f92672">*</span> inputs, size_t temp_count,
    InstructionOperand<span style="color:#f92672">*</span> temps) {
  <span style="color:#66d9ef">if</span> (output_count <span style="color:#f92672">&gt;=</span> Instruction<span style="color:#f92672">::</span>kMaxOutputCount <span style="color:#f92672">||</span>
      input_count <span style="color:#f92672">&gt;=</span> Instruction<span style="color:#f92672">::</span>kMaxInputCount <span style="color:#f92672">||</span>
      temp_count <span style="color:#f92672">&gt;=</span> Instruction<span style="color:#f92672">::</span>kMaxTempCount) {
    set_instruction_selection_failed();
    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nullptr</span>;
  }
  <span style="color:#75715e">// opcode = KArchDebugBreak
</span><span style="color:#75715e"></span>  Instruction<span style="color:#f92672">*</span> instr <span style="color:#f92672">=</span>
      Instruction<span style="color:#f92672">::</span>New(instruction_zone(), opcode, output_count, outputs,
                       input_count, inputs, temp_count, temps);
  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">Emit</span>(instr);
}
</code></pre></div><h3 id="references">References</h3>
<p><a href="https://doar-e.github.io/blog/2019/01/28/introduction-to-turbofan/">https://doar-e.github.io/blog/2019/01/28/introduction-to-turbofan/</a></p>

    </div>
    <div class="post-footer">
      
    </div>
  </article>

    </main>
  </body>
</html>
